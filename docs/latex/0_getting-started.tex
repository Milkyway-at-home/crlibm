\section{What is \crlibm?}

The \crlibm\ project aims at developing a portable, proven, correctly rounded,
and efficient mathematical library (\texttt{libm}) for double precision. 

\begin{description}
\item[correctly rounded] Current \texttt{libm} implementation do not
  always return the floating-point number that is closest to the exact
  mathematical result. As a consequence, different \texttt{libm}
  implementation will return different results for the same input,
  which prevents full portability of floating-point applications. In
  addition, few libraries support but the round-to-nearest mode of the
  IEEE754/IEC 60559 standard for floating-point arithmetic (hereafter
  usually referred to as the IEEE-754 standard). \crlibm\ provides the
  four rounding modes: To nearest, to $+\infty$, to $-\infty$ and to
  zero.

\item[portable] \crlibm\ is written in C and will be compiled by any
  compiler fulfilling basic requirements of the ISO/IEC 9899:1999
  (hereafter referred to as C99) standard.  This is the case of
  \texttt{gcc} version 3 and higher which is available on most
  computer systems. It also requires a floating-point implementation
  respecting the IEEE-754 standard, which is also available on
  most modern systems. \crlibm\ has been tested on a large range of
  systems.

\item[proven] Other libraries attempt to provide correctly-rounded
  result. For theoretical and practical reasons, this behaviour is
  difficult to prove, and in extreme cases termination is not even
  guaranteed. \crlibm\ intends to provide a comprehensive proof of the
  theoretical possibility of correct rounding, the algorithms used,
  and the implementation, assuming C99 and IEEE-754 compliance.

\item[efficient] performance and resource usage of \crlibm\ should be
  comparable to existing \texttt{libm} implementations, both in
  average and in the worst case. In contrast, other correctly-rounded
  libraries have worst case performance and memory consumption several
  order of magnitude larger than standard \texttt{libm}s.

\end{description}

The ultimate goal of the \crlibm\ project is to push towards the
standardization of correctly-rounded elementary functions.

\section{Compilation and installation}
See the \texttt{INSTALL} file in the main directory. This library is
developed using the GNU autotools, and can therefore be compiled on
most Unix-like systems by \texttt{./configure; make}. 


The command \texttt{make check} will launch the selftest.
For more advanced testing you will need to have MPFR installed (see
\url{www.mpfr.org}) and to pass the \texttt{--enable-mpfr} flag to
\texttt{configure}. For other flags, see \texttt{./configure --help} .

\section{Using \texttt{crlibm} functions in your program}

Currently \texttt{crlibm} functions have different names from the
standard \texttt{math.h} functions. For example, for the sine function
(\texttt{double sin(double)} in the standard \texttt{math.h}), you
have four different functions in \texttt{crlibm} for the four
different rounding modes. These functions are named \texttt{sin\_rn},
\texttt{sin\_ru}, \texttt{sin\_rd} and \texttt{sin\_rz} for round to the
nearest, round up, round down and round to zero respectively. These
functions are declared in the C header file \texttt{crlibm.h}.

The \texttt{crlibm} library relies on double-precision IEEE-754
compliant floating-point operations.  For some processors and some
operating systems (most notably IA32 and IA64 processors under
GNU/Linux), the default precision is set to double-extended.  On such
systems you will need to call the \texttt{crlibm\_init()} function
before using any \texttt{crlibm} function to ensure such compliance.
This has the effect of setting the processor flags to IEEE-754
double-precision with rounding to the nearest mode.  This function
returns the previous processor status, so that previous mode can be
restored using the function \texttt{crlibm\_exit()}. Note that you
probably only need one call to \texttt{crlibm\_init()} at the beginning
of your program, not one call before each call to a mathematical
function.

Here's an example function named \texttt{compare.c} using the cosine
function from \texttt{crlibm} library.

\begin{lstlisting}[label={chap0:lst:prog_example},caption={compare.c},firstnumber=1]
#include<stdio.h>
#include<math.h>
#include<crlibm.h>

int main(void){
  double x, res_libm, res_crlibm;

  crlibm_init(); /* no need here to save the old processor state returned by crlibm_init() */ 
  printf("Enter a floating point number: ");
  scanf("%lf", &x);
  res_libm = cos(x);
  res_crlibm = cos_rn(x);
  printf("\n x=%.25e \n", x);
  printf("\n cos(x) with the system : %.25e \n", res_libm);
  printf("\n cos(x) with crlibm     : %.25e \n", res_crlibm);
  return 0;
}
\end{lstlisting}

This example will be compiled with \texttt{gcc compare.c -lm -lcrlibm -o compare}


\section{Currently available functions}

The currently available functions are summarized in the following
table, where $x$ is of type $double$ and every function returns a
double-precision number. For trigonometric functions the angles are
expressed in radian.
\begin{center}
\begin{tabular}{|c|c|c|c|c|}    \hline
 & \multicolumn{4}{c|}{crlibm} \\ \cline{2-5}
 \raisebox{5pt}{C99} & to nearest & to $+ \infty$ & to $- \infty$ & to zero \\ \hline
    cos(x) & cos\_rn(x) & cos\_ru(x) & cos\_rd(x) & cos\_rz(x) \\ \hline
    sin(x) & sin\_rn(x) & sin\_ru(x) & sin\_rd(x) & sin\_rz(x) \\ \hline
    tan(x) & tan\_rn(x) & tan\_ru(x) & tan\_rd(x) & tan\_rz(x) \\ \hline
    cosh(x) & cosh\_rn(x) & cosh\_ru(x) & cosh\_rd(x) & cosh\_rz(x) \\ \hline
    sinh(x) & sinh\_rn(x) & sinh\_ru(x) & sinh\_rd(x) & sinh\_rz(x) \\ \hline
    atan(x) & atan\_rn(x) & atan\_ru(x) & atan\_rd(x) & atan\_rz(x) \\ \hline
    asin(x) & asin\_rn(x) & asin\_ru(x) & asin\_rd(x) & asin\_rz(x) \\ \hline
    exp(x) & exp\_rn(x) & exp\_ru(x) & exp\_rd(x) & exp\_rz(x) \\ \hline
    log(x) & log\_rn(x) & log\_ru(x) & log\_rd(x) & log\_rz(x) \\ \hline
    log2(x) & log2\_rn(x) & log2\_ru(x) & log2\_rd(x) & log2\_rz(x) \\ \hline
    log10(x) & log10\_rn(x) & log10\_ru(x) & log10\_rd(x) & log10\_rz(x) \\ \hline
\end{tabular}
\end{center}



\section{Writing portable floating-point programs}

Here are some rules to help you design programs which have to
produce exactly the same results on different architectures and
different operating systems.
\begin{itemize}
\item Try to use the same compiler on all the systems.
\item Demand C99 compliance (pass the \texttt{-C99},
  \texttt{-std=c99}, or similar flag to the compiler). For Fortran,
  demand F90 compliance.
\item Call \texttt{crlibm\_init()} before you begin floating-point
  computation. This ensures that the computations will all be done in
  IEEE-754 double-precision with round to nearest mode, which is the
  largest precision well supported by most systems. On IA32
  processors, problems may still occur for extremely large or
  extremely small values.
\item Do not hesitate to rely heavily on parentheses (the compiler
  should respect them according to the standards, although of course some
  won't). Many times, wondering where the parentheses should go in an
  expression like \texttt{a+b+c+d} will even help you improve the
  accuracy of your code.
\item Use \texttt{crlibm} functions in place of \texttt{math.h} functions.
\end{itemize}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "crlibm"
%%% End: 


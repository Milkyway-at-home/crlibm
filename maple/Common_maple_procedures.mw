<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="0"/><View-Properties><Zoom percentage="100"/></View-Properties><Styles><Layout leftmargin="0.0" name="_pstyle7" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle6" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle5" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle4" rightmargin="0.0"/><Layout alignment="left" firstindent="0.0" leftmargin="0.0" name="_pstyle2" rightmargin="0.0" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="_pstyle1" rightmargin="0.0"/><Layout alignment="left" bullet="none" name="Heading 3" spaceabove="0.0" spacebelow="0.0"/><Layout alignment="left" bullet="none" name="Heading 2" spaceabove="8.0" spacebelow="2.0"/><Layout alignment="centred" bullet="none" linespacing="0.5" name="Maple Output"/><Layout alignment="left" bullet="none" name="Heading 1" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="Normal" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle14" rightmargin="0.0"/><Layout alignment="left" firstindent="0.0" leftmargin="0.0" name="_pstyle13" rightmargin="0.0" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="_pstyle11" rightmargin="0.0"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input" readonly="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_cstyle57" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle55" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="Text" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" executable="false" name="_pstyle6" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="_pstyle4" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="false" family="Monospaced" foreground="[255,0,0]" name="_cstyle7" readonly="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_cstyle6" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle5" readonly="false"/><Font background="[0,0,0]" bold="true" executable="false" family="Lucida Bright" name="_cstyle1" readonly="false" size="18"/><Font background="[0,0,0]" bold="true" family="Serif" italic="true" name="Heading 3" opaque="false" size="14"/><Font background="[0,0,0]" bold="true" family="Serif" name="Heading 2" opaque="false" size="16"/><Font background="[0,0,0]" bold="true" family="Serif" name="Heading 1" opaque="false" size="18"/><Font background="[0,0,0]" executable="false" name="ParagraphStyle2" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" name="_cstyle63" readonly="false" size="12"/><Font background="[0,0,0]" family="Lucida Bright" foreground="[0,0,255]" name="2D Output" opaque="false" readonly="true" size="12"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="Page Number" readonly="false" underline="false"/><Font background="[0,0,0]" executable="false" name="_pstyle14" readonly="false"/></Styles><Page-Numbers enabled="false" first-number="1" first-numbered-page="1" horizontal-location="right" style="Page Number" vertical-location="bottom"/><Group><Input><Text-field layout="Normal" style="Text"><Font size="14">Evaluate this worksheet to produce Common_maple_procedures.m, which is used by the other worksheets in this directory</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">restart:
Digits:=150:
with(numapprox):
with(orthopoly):</Text-field></Input></Group><Section><Title><Text-field layout="_pstyle2" style="_cstyle1">Useful procedures for IEEE doubles</Text-field></Title><Section><Title><Text-field layout="Heading 2" style="Heading 2">Stuff for IEEE double conversions and manipulation</Text-field></Title><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">log2:=proc(x) evalf( log(x)/log(2) ) end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">ieeedouble converts a number to IEEE double format. 
returns sign (-1 or 1), exponent between -1022 and 1023, mantissa as a fraction between 0.5 and 1.
Handles denorms well, infinities more or less
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">ieeedouble:=proc(xx) 
local x, sign, logabsx, exponent, mantissa, infmantissa; 
x:=evalf(xx):
if (x=0) then 
  sign,exponent,mantissa := 0,0,0; 
else 
 if (x&lt;0) then sign:=-1:
 else sign:=1:
 fi:
 exponent := floor(log2(sign*x));
 if (exponent&gt;1023) then mantissa:=infinity: exponent=1023:
 elif (exponent&lt;-1022) then 
    # denorm
    exponent := -1023
 fi:
 infmantissa := sign*x*2^(52-exponent);
 if frac(infmantissa) &lt;&gt; 0.5 then mantissa := round(infmantissa)
 else
    mantissa := floor(infmantissa);
    if type(mantissa,odd) then mantissa := mantissa+1 fi;
 fi;
 Digits := 53;
 mantissa := mantissa*2^(-52);
fi;
sign,exponent,mantissa;
end:</Text-field></Input><Input><Text-field prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">
p<Font family="Lucida Bright" style="_pstyle6">ulp returns the precision of the ulp of x</Font></Text-field><Text-field layout="_pstyle7" style="_cstyle57"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">pulp:=proc(x)
local flt, ulpy;
flt:=ieeedouble(x);
ulpy:=-53+flt[2];
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Returns nearest IEEE double:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">nearest := proc(x)
  local sign, exponent, mantissa;

  sign,exponent,mantissa := ieeedouble(x);
  sign*mantissa*2^(exponent);
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle4" style="_pstyle4"/><Text-field layout="_pstyle4" style="Text">returns a string containing the hexadecimal representation of the double nearest to input x.</Text-field><Text-field layout="_pstyle4" style="_pstyle4"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">ieeehexa:= proc(x)
  local signe, hex1, hex2, ma, manti, expo, expos, bina, bin1, bin2, dec1, dec2, resultat;
  if(x=0) then resultat:=["00000000","00000000"];
  elif(x=-0) then resultat:=["80000000","00000000"];
  elif(x=2) then resultat:=["40000000","00000000"];
  elif(x=-2) then resultat:=["C0000000","00000000"];
  else
   ma:=ieeedouble(x);
   expo:=ma[2]:
   if (ma[1]=-1) then 
    manti:=2**64 + 2**63+(ma[3]-1)*2**52+(expo+1023)*2**52;
   else 
     manti:=2**64 + (ma[3]-1)*2**52+(expo+1023)*2**52;
   fi:
   hex2:=convert(manti, hex); 
   hex2:=convert(hex2, string):  
  
   resultat:=[substring(hex2,2..9), substring(hex2,10..18)];
  end if;
  resultat;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle4" style="Text"/><Text-field layout="_pstyle4" style="Text">reciprocal of the previous</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">hexa2ieee:= proc(hexa)
local dec, bin, expobin, expo, mantis, sign, hex1, hex2, hexcat;
global res;

hex1:= op(1, hexa):
hex2:= op(2, hexa):
hexcat:= cat(hex1, hex2);
dec:= convert(hexcat, decimal, hex):

if(dec &gt;= 2**63) then
  dec = dec - 2**63:
  sign:= -1:else
  sign:= 1:
fi;  
expo:= trunc(dec/(2**52))-1023:
mantis:= 1+frac(dec/(2**52));
res:= evalf(sign*2**(expo)*mantis);
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Print a number x in Low or Big Endian representation in opened file "fd":</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">printendian:=proc(fd,x,isbig)
local xhl:
xhl:=ieeehexa(x):

if(isbig=0 or isbig=1) then
  fprintf(fd,"{{0x%+0.8s,0x%+0.8s}} /* %+0.10e */", xhl[2-isbig], xhl[isbig+1], x):
else
  print("ERROR, isbig must be equal to 0 or 1");
end if:
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle6" style="_pstyle6"><Font style="_cstyle57">hi_lo takes an arbitrary precision number x and returns two doubles such that:</Font></Text-field><Text-field layout="_pstyle7" style="_cstyle57">x ~ x_hi + x_lo</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">hi_lo:= proc(x)
local x_hi, x_lo, res:
x_hi:= nearest(evalf(x)):
res:=x-x_hi:
if (res = 0) then
  x_lo:=0:
else
  x_lo:=nearest(evalf(res)):
end if;
x_hi,x_lo;
end:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">
same as hi_lo, but returns hexadecimal strings</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">ieeehexa2:=proc(x)
local reshi, reslo, hexhi, hexlo;
reshi:=nearest(x);
hexhi:=ieee2hexa(reshi);
reslo:= nearest(res-reshi);
hexlo:=ieee2hexa(reslo);
reshi, reslo;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"/><Text-field layout="Normal" style="Text">Computes the constant for the round-to-nearest test. 
delta is the overall relative error of the approximation scheme</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_rn_constant := proc(delta)
  local k;
  k := trunc(-log2(delta)) - 53: 
  nearest(  1+ 2**(-52) + (2**(54+k)*delta)  /  ( (2**k-1) * (1-2**(-53)) )  ):
end proc:</Text-field></Input></Group></Section><Section><Title><Text-field layout="Heading 2" style="Heading 2">Stuff about truncated polynomials</Text-field></Title><Section collapsed="true"><Title><Text-field layout="Heading 3" style="Heading 3">Truncate a polynomial </Text-field></Title><Group><Input><Text-field layout="Normal" style="Text">
poly_exact takes a polynomial in x with arbitrary precision coefficients, and returns a truncated polynomial where coefficients are IEEE doubles.</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">poly_exact:=proc(P)
local deg,i, coef, coef_t, Q:
Q:= 0:
convert(Q, polynom):
deg:=degree(P,x):
  for i from 0 to deg do
    coef:=coeff(P,x,i):
    coef_t:=nearest(coef):
    Q:= Q + coef_t*x^i:
  od:
return(Q);
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57">Like poly_exact, but the n first coefficients are exactly representable as the sum of two doubles.</Text-field><Text-field layout="_pstyle7" style="_cstyle57">(to actually get the two doubles, use procedure hi_lo)
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">poly_exact2:=proc(P,n)
local deg,i, coef, coef_hi, coef_lo, Q:
Q:= 0:
convert(Q, polynom):
deg:=degree(P,x):
  for i from 0 to deg do
    coef :=coeff(P,x,i):
    coef_hi, coef_lo:=hi_lo(coef):
    Q:= Q + coef_hi*x^i:
    if(i&lt;n) then
        Q := Q + coef_lo*x^i:
    fi:
  od:
  return(Q);
end:
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="Heading 3" style="Heading 3">Compute a bound on the accumulated rounding error caused by the Horner evaluation of a truncated polynomial </Text-field></Title><Group><Input><Text-field layout="Normal" style="Text">Computes the accumulated rounding error during the polynomial evaluation.
P is the polynomial.
xmax is the max value of |x|.
n is the degree when P is computed in double double. The first double-double operation is an addition.</Text-field><Text-field layout="Normal" style="Text">
returns max absolute error, min of the function, max of the function. 
</Text-field><Text-field layout="Normal" style="Text">This procedure also checks on the fly that the fast (test-free) versions of the double-double addition can be used, i.e. that for all x, at each Horner step i computing ci+x*Si, we have |ci|&gt;|x*Si|. It prints warnings if it not the case. </Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_abs_rounding_error:=proc(poly,xmax, nn)
local n, deg, delta, deltap, i, S, P, Snorm, Smin, Smax, prec:
deltap:=0:
delta:=0:
deg:=degree(poly):

prec:=53; # precision of the first iterations

S:=coeff(poly, x, deg):
Smax:=abs(S):
Smin:=Smax:

if nn&lt;0 then n:=0: else n:=nn: fi:# sometimes called by compute_rel_rounding_error with n=-1

for i from (deg-1) to 0 by -1 do
  P:= convert(S*x, polynom):
  Smin := abs(coeff(poly,x,i)) - xmax*Smax : 
  if(Smin&lt;=0) then 
    printf("Warning! in compute_abs_rounding_error, Smin&lt;=0 at iteration %d, consider decreasing xmax\n",i);
  fi:
  delta:= evalf(xmax*deltap + 2**(-prec)*xmax*Smax):
  if i&lt;n then 
    # fast Add22 ?    
    if abs(coeff(poly,x,i)) &lt; xmax*Smax  # may be improved to xmax*Smax/2
    then printf("WARNING Add22 cannot be used at step %d, use Add22Cond\n" , i  );   
         printf("    coeff=%1.20e,  xmax*Smax=%1.20e"  ,  abs(coeff(poly,x,i)),  xmax*Smax );
    fi:
  fi:
  S:=convert(P+coeff(poly,x,i), polynom):
  Snorm:=evalf(infnorm(S, x=-xmax..xmax)):
  if i=n-1 then prec:=100: fi:  # from the addition of the n-1-th iteration
  deltap:= evalf(delta + 2**(-prec)*(delta + Snorm)): 
  Smax := Snorm + deltap:  
od:
deltap, Smin, Smax;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"/><Text-field layout="Normal" style="Text">Computes the total relative rounding error</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_rel_rounding_error:=proc(poly,xmax, n)
local deg, p, rho, deltap, Smin, Smax:

deg:=degree(poly):
if(n&gt;0) then p:=100: else p:=53: fi: 

if coeff(poly,x, 0) = 0 then
   deltap, Smin, Smax := compute_abs_rounding_error(poly/x,xmax, n-1):
   rho :=  (2^(-p)*(Smax+deltap) +deltap ) / Smin :
else
   deltap, Smin, Smax := compute_abs_rounding_error(poly,xmax, n):
   rho := deltap /  Smin:
fi:
rho;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"/></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Computes the accumulated rounding error during the polynomial evaluation.
P is the polynomial.
xmax is the max value of |x|.
n is the degree when P is computed in double double. The first double-double operation is a multiplication (probably less useful).</Text-field><Text-field layout="Normal" style="Text">
returns max absolute error, min of the function, max of the function. 
</Text-field><Text-field layout="Normal" style="Text">This procedure also checks on the fly that the fast (test-free) versions of the double-double addition can be used, i.e. that for all x, at each Horner step i computing ci+x*Si, we have |ci|&gt;|x*Si|. It prints warnings if it not the case. </Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_abs_rounding_error_firstmult:=proc(poly,xmax, nn)
local n, deg, delta, deltap, i, S, P, Snorm, Smin, Smax, prec:
deltap:=0:
delta:=0:
deg:=degree(poly):

prec:=53; # precision of the first iterations

S:=coeff(poly, x, deg):
Smax:=abs(S):
Smin:=Smax:

if nn&lt;0 then n:=0: else n:=nn: fi:# sometimes called by compute_rel_rounding_error with n=-1

for i from (deg-1) to 0 by -1 do
  if i=n-1 then prec:=100: fi:  # from the mult of the n-1-th iteration
  P:= convert(S*x, polynom):
  Smin := abs(coeff(poly,x,i)) - xmax*Smax : 
  if(Smin&lt;=0) then 
    printf("Warning! in compute_abs_rounding_error, Smin&lt;=0 at iteration %d, consider decreasing xmax\n",i);
  fi:
  delta:= evalf(xmax*deltap + 2**(-prec)*xmax*Smax):
  if i&lt;n then 
    # fast Add22 ?    
    if abs(coeff(poly,x,i)) &lt; xmax*Smax  # may be improved to xmax*Smax/2
    then printf("WARNING Add22 cannot be used at step %d, use Add22Cond\n" , i  );   
         printf("    coeff=%1.20e,  xmax*Smax=%1.20e"  ,  abs(coeff(poly,x,i)),  xmax*Smax );
    fi:
  fi:
  S:=convert(P+coeff(poly,x,i), polynom):
  Snorm:=evalf(infnorm(S, x=-xmax..xmax)):
  deltap:= evalf(delta + 2**(-prec)*(delta + Snorm)): 
  Smax := Snorm + deltap:  
od:
deltap, Smin, Smax;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"/><Text-field layout="Normal" style="Text">Computes the total relative rounding error</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_rel_rounding_error_firstmult:=proc(poly,xmax, n)
local deg, p, rho, deltap, Smin, Smax:

deg:=degree(poly):
if(n&gt;0) then p:=100: else p:=53: fi: 

if coeff(poly,x, 0) = 0 then
   deltap, Smin, Smax := compute_abs_rounding_error_firstmult(poly/x,xmax, n-1):
   rho :=  (2^(-p)*(Smax+deltap) +deltap ) / Smin :
else
   deltap, Smin, Smax := compute_abs_rounding_error_firstmult(poly,xmax, n):
   rho := deltap /  Smin:
fi:
rho;
end proc:</Text-field></Input></Group></Section><Section><Title><Text-field layout="Heading 3" style="Heading 3">Compute a good truncated polynomial approximation for a function</Text-field></Title><Group><Input><Text-field layout="Normal" style="Text">Computes an approximation to a function of x f, as a truncated polynomial of deegree deg with the n first coefficients exactly representable as double-double.
The function f(x) must have as input interval xmin..xmax
returns [ truncated polynomial, relative approx error of trunc. poly.  ,  infinite precision polynomial,   rel. error of inf. prec. poly ]</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">poly_trunc_classic:=proc(f,deg,xmin,xmax,n) 
  local pe, repe, pt, ppe, rept, maxpt;
  pe:=minimax( f,  x=-xmax..xmax,  [deg,0],  1,  'err'):
  pt := poly_exact2(pe,n):
  rept := infnorm( 1-pt/f, x=-xmax..xmax) :
  maxpt := infnorm( pt, x=-xmax..xmax) :
  pt,rept, maxpt:
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Computes a truncated polynomial of degree deg with the two first coefficients stored as double-doubles. 
The function f(x) must have as input interval xmin..xmax</Text-field><Text-field layout="Normal" style="Text">returns [ truncated polynomial, relative error of trunc. poly.  ,  infinite precision polynomial,   rel. error of inf. prec. poly ]</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">poly_trunc_f2d_2:=proc(f,deg,xmin,xmax) 
  local pe, repe, pt, c0, c1, c2, ppe, rept, maxpt, err;
  pe:=minimax(  f,  x=-xmax..xmax,  [deg,0],  1,  'err'):
  pt := poly_exact2(pe,2):
  c0:=coeff(pt,x,0):
  c1:=coeff(pt,x,1):
  c2:=coeff(pt,x,2):
  ppe:=minimax(  (f - c0 - c1 * x - c2*x*x) ,  x=-xmax..xmax,  [deg,0],  1,  'err'):
  ppe:=ppe - coeff(ppe,x,0) - coeff(ppe,x,1)*x- coeff(ppe,x,1)*x*x:
  pt := poly_exact2(ppe,2) + c0 + c1*x + c2*x*x:
  rept := infnorm( 1-pt/f, x=-xmax..xmax) :
  maxpt := infnorm( pt, x=-xmax..xmax) :
  pt,rept,maxpt:
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Computes a truncated polynomial of degree deg with the first coefficient stored as double-double.</Text-field><Text-field layout="Normal" style="Text"> The function f(x) must have as input interval xmin..xmax
returns [ truncated polynomial, relative error of trunc. poly.  ,  infinite precision polynomial,   rel. error of inf. prec. poly ]</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">poly_trunc_f2d_1:=proc(f,deg,xmin,xmax) 
  local pe, repe, pt, c0, c1, ppe, rept, maxpt, err;
  pe:=minimax(  f ,  x=-xmax..xmax,  [deg,0],  1,  'err'):
  pt := poly_exact2(pe,1):
  c0:=coeff(pt,x,0):
  c1:=coeff(pt,x,1):
  ppe:=minimax(  (f - c0 - c1 * x) ,  x=-xmax..xmax,  [deg,0],  1,  'err'):
  ppe:=ppe - coeff(ppe,x,0) - coeff(ppe,x,1)*x:
  pt := poly_exact2(ppe,1) + c0 + c1*x:
  rept := infnorm( 1-pt/f, x=-xmax..xmax) :
  maxpt := infnorm( pt, x=-xmax..xmax) :
  pt,rept,maxpt:
end proc:</Text-field></Input></Group></Section></Section></Section><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">save log2, pulp, nearest,ieeedouble, hi_lo, ieeehexa, printendian, hexa2ieee, ieeehexa2, poly_exact, poly_exact2,  compute_rel_rounding_error,  compute_abs_rounding_error, compute_rel_rounding_error_firstmult,  compute_abs_rounding_error_firstmult, compute_rn_constant, poly_trunc_f2d_1, poly_trunc_f2d_2, poly_trunc_classic, "Common_maple_procedures.m"; </Text-field></Input></Group><Section collapsed="true"><Title><Text-field layout="Heading 1" style="Heading 1">Stuff for SCS</Text-field></Title><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false">Global parameters</Font></Text-field></Title><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Don\264t forget to set all the parameters here</Font></Text-field><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">NB_WORDS := 2:
NB_BITS  := 30:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false">GetSCS_real</Font></Text-field></Title><Text-field layout="_pstyle13" style="_cstyle63">This procedure convert a decimal number into it SCS representation.</Text-field><Text-field layout="_pstyle13" style="_cstyle63">       x : input number to convert into it SCS representation</Text-field><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">GetSCS_real := proc(x)
local exception, index, sign, mantissa, nb, i;

if x &lt;&gt; 0 then
  exception := 1;
  if x &gt; 0 then
    sign  := 1;
    nb    := x;
  elif x &lt; 0 then
    sign := -1;
    nb   := -x;
  end if;
  
  index := 0;

  if nb &gt;= 1 then
    for i from 0 while nb &gt; (2^(NB_BITS+1)-1) do
      index := index+1;
      nb    := nb * 2^(-NB_BITS);
    end do; 
  else
    for i from 0 while nb &lt; 1 do
      index := index-1;
      nb    := nb * 2^(NB_BITS);
    end do; 
  end if;

  for i from 0 by 1 to (NB_WORDS-1) do
    mantissa[i] := trunc(nb);
    nb          := (nb - mantissa[i]) * 2^(NB_BITS);
  end do;
else
  for i from 0 by 1 to (NB_WORDS-1) do
    mantissa[i] := 0;
  end do;

  index     := 1;
  exception := x;
  sign      := 1;
end if;
mantissa[NB_WORDS]   := exception;
mantissa[NB_WORDS+1] := index;
mantissa[NB_WORDS+2] := sign;

return mantissa;
end proc:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false">SetSCS_real</Font></Text-field></Title><Text-field layout="_pstyle7" style="_cstyle57">Convert an SCS number into a rational number</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">SetSCS_real := proc(tab)
  local res, i;

  if (tab[NB_WORDS] &lt;&gt; 1) then
    return tab[NB_WORDS];
  end if;

  res := 0;
  for i from (NB_WORDS-1) by -1 while i&gt;=0 do
    res := 2^(-NB_BITS)*res + tab[i] 
  end do;
  
res := tab[NB_WORDS+2]*(res * 2.^(NB_BITS * tab[NB_WORDS+1]));

return res;

end proc:
</Text-field></Input></Group><Text-field layout="_pstyle6" style="_pstyle6"/></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false">WriteSCS</Font></Text-field></Title><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">Write Into file fd the SCSS number stored into the table tab where
tab[0..(NB_WORDS-1)] store the mantissa
tab[NB_WORDS] store the exception
tab[NB_WORDS+1] store the index
tab[NB_WORDS+2] store the sign
</Text-field><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">WriteSCS := proc(fd, tab)
 local i;

fprintf(fd,"{{");

fprintf(fd,"0x%+0.16x, ", tab[0]);
for i from 1 by 1 to (NB_WORDS-2) do
  fprintf(fd,"0x%+0.16x, ", tab[i]);
  if (i mod 4 = 3) then
    fprintf(fd,"\n"); 
  fi;
end do;
fprintf(fd,"0x%+0.16x},\n", tab[NB_WORDS-1]);
if (tab[NB_WORDS]=1) then
  fprintf(fd,"DB_ONE, %3d, %3d ", tab[NB_WORDS+1], tab[NB_WORDS+2]);
else
  # the only other possible value is 0 so ...
  fprintf(fd,"{0x00000000, 0x00000000}, %3d, %3d ", tab[NB_WORDS+1], tab[NB_WORDS+2]);
end if;

fprintf(fd, "} \n");
end proc:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false">GetSCS_poly</Font></Text-field></Title><Text-field layout="_pstyle6" style="_pstyle6"/><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">get_nb_terms := proc(poly)
 local i, deg_poly;

 deg_poly := degree(poly);
 for i from deg_poly by -1 while i&gt;=0 do
  if coeff(poly, x, i)=0 then
   deg_poly := deg_poly-1;
  end if;
 end do;

 return deg_poly;
end proc:</Text-field><Text-field layout="_pstyle6" prompt="&gt; " style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">Convert each coefficient of a polynom into it SCSS representation

</Text-field><Text-field layout="_pstyle11" style="ParagraphStyle2"><Font style="_cstyle6">poly : input polynom 
  file : name of the file where to put the result</Font><Font style="_cstyle7">
GetSCS_poly := proc(poly, file)
  local i, fd, mantissa, deg;
  #fclose(fd);
  try
    fd := fopen(file, WRITE,TEXT);
  finally
    fprintf(fd,"static const SCS constant_poly[%d]=\n",get_nb_terms(poly)+1);
    deg := degree(poly); 

    fprintf(fd,"/* ~%e */ \n{", coeff(poly, x, deg));   
    mantissa := GetSCS_real(coeff(poly, x, deg));
    WriteSCS(fd, mantissa); 
    for i from (deg-1) by (-1) while i&gt;=0 do
      if (coeff(poly, x, i)&lt;&gt;0) then 
        fprintf(fd,",\n/* ~%e */ \n", coeff(poly, x, i));
        mantissa := GetSCS_real(coeff(poly, x, i));
        WriteSCS(fd, mantissa, 0);
      end if; 
    end do;
    fprintf(fd,"};\n");
   
  fclose(fd);
  end try;
end proc:</Font></Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">GetSCS_poly(Poly_Re, "/home/cdaramy/polyhex_log.h");</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMtSSxHZXRTQ1NfcG9seUc2IjYkSShQb2x5X1JlR0YlUTwvaG9tZS9jZGFyYW15L3BvbHloZXhfbG9nLmhGJQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="Heading 2" style="Heading 2">hexa_scs</Text-field></Title><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Une derni\350re proc\351dure pour \351crire les nombres SCS (floatant exacts) en hexad\351cimal dans un fichier ".h"</Font></Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle11" prompt="&gt; " style="ParagraphStyle2"><Font style="_cstyle5">hexa_scs := proc (x) 
  local i, elem, mantisse, exposant, resultat; 
  global ulp, ulp_inv;
  if (x :: list) then
    [seq (hexa(elem), elem=x)];
  else
    Digits := 60;
    if (x = 0)</Font><Font style="_cstyle6"> </Font><Font style="_cstyle5">then 
      resultat := 0;
    else
      exposant := floor(log[2](abs(evalf(x))));
      if (exposant &lt; -126) then exposant := -126; fi;
      resultat := round (ulp_inv * (abs(x) * 2^(-exposant) -1)) + ulp_inv / 2 * (exposant + 2^(lgex-1) - 1);
      if (x &lt; 0) then resultat := resultat + ulp_inv * 2^(lgex-1); fi; 
    fi;
  fi;
  convert(resultat, hex);
end:</Font><Font family="Lucida Bright">
</Font></Text-field></Input></Group><Text-field layout="_pstyle14" style="_pstyle14"/></Section></Section><Section collapsed="true"><Title><Text-field layout="Heading 1" style="Heading 1">Tests and scratch</Text-field></Title><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/></Worksheet>
<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="0"/><View-Properties><Zoom percentage="100"/></View-Properties><Styles><Layout alignment="left" leftmargin="0.0" name="Warning" rightmargin="0.0"/><Layout alignment="centred" leftmargin="0.0" linespacing="0.5" name="_pstyle9" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle7" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle6" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle5" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle4" rightmargin="0.0"/><Layout alignment="left" firstindent="0.0" leftmargin="0.0" name="_pstyle2" rightmargin="0.0" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="_pstyle1" rightmargin="0.0"/><Layout alignment="centred" leftmargin="0.0" linespacing="0.5" name="Maple Output" rightmargin="0.0"/><Layout alignment="left" bullet="none" name="Heading 1" spaceabove="8.0" spacebelow="4.0"/><Layout alignment="left" leftmargin="0.0" name="Error" rightmargin="0.0"/><Layout leftmargin="0.0" name="Normal" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle14" rightmargin="0.0"/><Layout alignment="left" firstindent="0.0" leftmargin="0.0" name="_pstyle13" rightmargin="0.0" spaceabove="8.0" spacebelow="4.0"/><Layout alignment="left" firstindent="0.0" leftmargin="0.0" name="_pstyle12" rightmargin="0.0" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="_pstyle11" rightmargin="0.0"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input" readonly="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_cstyle57" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle55" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="Text" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" executable="false" family="Monospaced" foreground="[0,0,255]" name="Warning" readonly="true" size="10"/><Font background="[0,0,0]" executable="false" name="_pstyle9" readonly="false"/><Font background="[0,0,0]" executable="false" name="_pstyle6" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_pstyle5" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="_pstyle4" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="false" family="Monospaced" foreground="[255,0,0]" name="_cstyle7" readonly="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_cstyle6" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle5" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_pstyle1" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="_cstyle2" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="false" family="Lucida Bright" name="_cstyle1" readonly="false" size="18"/><Font background="[0,0,0]" bold="true" family="Serif" name="Heading 1" opaque="false" size="18"/><Font background="[0,0,0]" executable="false" name="ParagraphStyle2" readonly="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="ParagraphStyle1" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" name="_cstyle63" readonly="false" size="12"/><Font background="[0,0,0]" bold="true" executable="false" family="Lucida Bright" name="_cstyle62" readonly="false" size="18"/><Font background="[0,0,0]" executable="false" family="Monospaced" foreground="[255,0,255]" name="Error" readonly="true" size="10"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" foreground="[0,0,255]" name="2D Output" readonly="false" underline="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="Page Number" readonly="false" underline="false"/><Font background="[0,0,0]" executable="false" name="_pstyle14" readonly="false"/></Styles><Page-Numbers enabled="false" first-number="1" first-numbered-page="1" horizontal-location="right" style="Page Number" vertical-location="bottom"/><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">restart:
Digits:=150:</Text-field></Input></Group><Section><Title><Text-field layout="_pstyle2" style="_cstyle1">Useful procedures</Text-field></Title><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">with(numapprox);
with(orthopoly):</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3L0koY2hlYmRlZ0c2IkkpY2hlYm11bHRHRiVJKWNoZWJwYWRlR0YlSSljaGVic29ydEdGJUkqY2hlYnlzaGV2R0YlSSxjb25mcmFjZm9ybUdGJUktaGVybWl0ZV9wYWRlR0YlSStob3JuZXJmb3JtR0YlSShpbmZub3JtR0YlSShsYXVyZW50RzYkSSpwcm90ZWN0ZWRHRjBJKF9zeXNsaWJHRiVJKG1pbmltYXhHRiVJJXBhZGVHRiVJJnJlbWV6R0Yl</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle4" style="Text">Renvoie l'arrondi double IEEE au plus pres  de x (Jean-Michel):</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">nearest := proc(u)
local arrondi, signe, x, exposant, mantisseinfinie, mantisse;
Digits:=200:
if u = 0 then arrondi := 0
else 
  if (u &lt; 0) then signe := -1; x := -u else signe := 1; x := u fi;
  exposant := floor(evalf(log(x)/log(2.0)));
  mantisseinfinie := x*2^(52-exposant);
  if frac(mantisseinfinie) &lt;&gt; 0.5 then mantisse := round(mantisseinfinie)
   else
     mantisse := floor(mantisseinfinie);
     if type(mantisse,odd) then mantisse := mantisse+1 fi;
   fi;
   arrondi := signe*mantisse*2^(exposant-52)
fi;
arrondi;
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="ParagraphStyle1"><Font encoding="ISO8859-1" style="_cstyle57">La proc\351dure IEEEdouble c</Font><Font style="_cstyle2">onvertit un nombre au format double IEEE. </Font></Text-field><Text-field layout="_pstyle4" style="Text">renvoie Exposant, fraction de la mantisse, mantisse en binaire.</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">IEEEdouble:=proc(x) local signe, logabsx, exposant, mantisse, mantisseinfinie, resultat; 
 Digits:=200;
if (x=0) then [0,0,0]; 
else 
 if (x&lt;0) then signe:=-1:
 else signe:=1:
 fi:
 exposant := floor(evalf(log(signe*x)/log(2.0)));
 if (exposant&gt;1023) then mantisse:=infinity:
 elif (exposant&lt;-1022) then mantisse:=0:
 else 
  mantisseinfinie := signe*x*2^(52-exposant);
  if frac(mantisseinfinie) &lt;&gt; 0.5 then mantisse := round(mantisseinfinie)
   else
     mantisse := floor(mantisseinfinie);
     if type(mantisse,odd) then mantisse := mantisse+1 fi;
   fi;
 mantisse:= signe*mantisse*2**(-52);
 Digits := 53;
 resultat:=convert(mantisse*2.0^(exposant),binary);
 fi;
[exposant,mantisse, resultat];
fi;
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">IEEEdouble(-0.1825);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3JSEiJCMhMUotKlInUSJRayIiMUNFJW8hKioqZTciJCFWKzYsLDY2KzU1Kys2LCw2Nis1NSsrNiwsNiwiISNi</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">La proc\351dure poly_exact prend en entr\351e un polynome en x \340 coefficients "r\351els" et retourne le polynome tronque dont les coefficients sont EXACTEMENT repr\351sentables en machine, au format double.</Font></Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">poly_exact:=proc(P)
local deg,i, coef, coef_t:
global Q:
Q:= 0:
convert(Q, polynom):
deg:=degree(P,x):
  for i from 0 to deg do
    coef:=coeff(P,x,i):
    if ( coef=0 ) then;
    else 
      coef_t:=IEEEdouble(coef):
    Q:= Q+coef_t[2]*2**(coef_t[1])*x^i:
    fi:
  od:
return(evalf(Q));
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">Poly:=1.1542+0.0002154*x+1542.0777*x^2+2.1542*x^3;
degree(Poly,x);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSVQb2x5RzYiLCokIiZVOiIhIiUiIiJJInhHRiUkIiVhQCEiKCokRisiIiMkIil4MlU6RikqJEYrIiIkJCImVTojRik=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiQ=</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">poly_exact(Poly);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMsKiQiYXQrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrREpxJmZOLVlMPihbQStwLzNGKikqKioqKioqKioqPmE2ISRcIiIiIkkieEc2IiQiYXQrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrK3ZWQmxvRytudUdXY0YrM1YwUTpYMFcvKysrKysrYUAhJGAiKiRGKCIiIyQiYXQrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrRDE5V3hWbms6ZCc0LiUpXCsrKytxeD9hIiEkWSIqJEYoIiIkJCJhdCsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKytESnEmZk4tWUw+KFtBK3AvM0YqKSoqKioqKioqKio+YUBGJg==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Moulinette qui prend un "r\351el" x en entr\351e et renvoie deux doubles tels que:</Font></Text-field><Text-field layout="_pstyle7" style="_cstyle57">x ~ x_hi + x_lo</Text-field><Text-field layout="_pstyle7" style="_cstyle57"> </Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">hi_lo:= proc(x)
global x_hi, x_lo, res:
local tamp:
x_hi:= nearest(evalf(x)):
res:=x-x_hi:
if (res = 0) then
  x_lo:=0:
else
  x_lo:=nearest(evalf(res)):
end if;
(x_hi,x_lo);
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">hi_lo(0.125460002548778000000000125487);
hi_lo(10);
</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiQjIjFEJ0dlJ0g8P1giMm9SJyo9cXpHZyQjITFcJSo9bnQsKmYnIkI3RDpUP0ptTlhgb0oyci5cJw==</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiQiIzUiIiE=</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Cette proc\351dure fait comme la premiere (poly_exact), sauf qu'elle renvoie les n premiers coefficient stock\351s sur deux doubles. </Font>
Q est un tableau qui contient pour chaque coefficient, les deux doubles exacts.</Text-field><Text-field layout="_pstyle7" style="_cstyle57">psup est le polynome dont les coefficients sont les doubles de poids les plus forts.</Text-field><Text-field layout="_pstyle7" style="_cstyle57">pinf est le polynome dont les coefficients sont les doubles de poids les plus faibles.</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">poly_exact2:=proc(P,n)
local i, coef, coef_t:
global deg, Q, psup, pinf, pfull:
psup:=0: pinf:=0:
Q:=[];
convert(psup, polynom): convert(pinf, polynom):
deg:=degree(P,x):
  for i from 0 to deg do
    coef:=coeff(P,x,i):
    if (coef=0) then
      Q:= (Q,[0,0]):
    elif(coef=1) then
        Q:= (Q,[1,0]):
        psup:=psup+x^i:
    else        
      coef_t:=hi_lo(coef):
      Q:= (Q,[coef_t]):
      psup:=psup + coef_t[1]*x^i:
        if(i&lt;n) then
        pinf:=pinf + coef_t[2]*x^i:
        fi;
    end if;
  od:
Q:=Q[2..deg+2];
pfull:=expand(psup+pinf):
end:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57">Exemple:</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">pol:=1.254+2*x+x^2+6*x^3+3.5*x^4;
degree(pol,x);
tab:=poly_exact2(pol,2);
</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSRwb2xHNiIsLCQiJWE3ISIkIiIiSSJ4R0YlIiIjKiRGK0YsRioqJEYrIiIkIiInKiRGKyIiJSQiI04hIiI=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiU=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSR0YWJHNiIsLCMiQkRFISlcdzInUTpybShHbWklcFMiQmNpZD9nOiR5RW5VZU9iPVhLIiIiSSJ4R0YlIiIjKiRGK0YsRioqJEYrIiIkIiInKiRGKyIiJSMiIihGLA==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle4" style="_pstyle4"/><Text-field layout="_pstyle4" style="Text"><Font encoding="ISO8859-1">Renvoie l'\351criture hexadecimale du nombre double IEEE associ\351 a l'entree x</Font></Text-field><Text-field layout="_pstyle4" style="_pstyle4"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">Hexa:= proc(x)
  local unite;
  global ma, manti, expo, expos, bina, dec, resultat;
  Digits:=70:
  if(x=0) then resultat:="0000000000000000";
  elif(x=-0) then resultat:="8000000000000000";
  elif(x=2) then resultat:="4000000000000000";
  elif(x=-2) then resultat:="C000000000000000";
  else
  ma:=IEEEdouble(x):
  expo:=ma[1]:
  if (ma[2]&lt;0) then unite:=-1; else unite:=1; fi:
  manti:=unite*round(((ma[3]*10**(-expo))-unite)*10**52):
  expos:=convert((expo+1023), binary)*10**52:
    
   if (ma[2]&lt;0) then 
     bina:=expos+manti+10**63:
   else
     bina:=expos+manti:
   end if:  
   dec:=convert(bina, decimal, binary):
   resultat:=convert(dec, hex);
  end if;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle4" style="_pstyle4"/><Text-field layout="_pstyle4" style="Text"><Font encoding="ISO8859-1"> Moulinette inverse de Hexa2ieee, en entr\351e, on prend un hexad\351cimal sur 16 chiffres, \351crit entre crochets et on renvoie un double IEEE.</Font></Text-field><Text-field layout="_pstyle4" style="_pstyle4"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">ieee2Hexa:= proc(x)
  local signe, hex1, hex2, ma, manti, expo, expos, bina, bin1, bin2, dec1, dec2, resultat;
  if(x=0) then resultat:=["00000000","00000000"];
  elif(x=-0) then resultat:=["80000000","00000000"];
  elif(x=2) then resultat:=["40000000","00000000"];
  elif(x=-2) then resultat:=["C0000000","00000000"];
  else
   ma:=IEEEdouble(x);
   expo:=ma[1]:
   if (ma[2]&lt;0) then 
    manti:=2**64 + 2**63+(-ma[2]-1)*2**52+(expo+1023)*2**52;
   else 
     manti:=2**64 + (ma[2]-1)*2**52+(expo+1023)*2**52;
   fi:
   hex2:=convert(manti, hex); 
   hex2:=convert(hex2, string):  
  
   resultat:=[substring(hex2,2..9), substring(hex2,10..18)];
  end if;
  resultat;
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">ieee2Hexa(21);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3JFEpNDAzNTAwMDA2IlEpMDAwMDAwMDBGJQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle4" style="Text">Procedures reciproque</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">Hexa2ieee:= proc(hexa)
local dec, bin, expobin, expo, mantis, sign, hex1, hex2, hexcat;
global res;

hex1:= op(1, hexa):
hex2:= op(2, hexa):
hexcat:= cat(hex1, hex2);
dec:= convert(hexcat, decimal, hex):

if(dec &gt;= 2**63) then
  dec = dec - 2**63:
  sign:= -1:
else
  sign:= 1:
fi;  
expo:= trunc(dec/(2**52))-1023:
mantis:= 1+frac(dec/(2**52));
res:= evalf(sign*2**(expo)*mantis);
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">Hexa2ieee(ieee2Hexa(1.2));</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMkImF0KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrXSg9bmpGTFowJFFRUCpcLHo1ZmIqKioqKioqKioqKioqKj4iISRcIg==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle9" style="_pstyle9"/><Text-field layout="_pstyle4" style="Text">Retourne l'ecriture hexadecimale d'un nombre ecrit sur deux double IEEE. </Text-field><Text-field layout="_pstyle9" style="_pstyle9"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">H2:=proc(res)
local ie1, reshi, ie2, reslo;
ie1:=IEEEdouble(res);
reshi:=evalf(ie1[2]*2**(ie1[1]));
ret1:=ieee2hexa(reshi);
ie2:=IEEEdouble(res-reshi);
reslo:=evalf(ie2[2]*2**(ie2[1]));
ret2:=ieee2hexa(reslo);
[ret1, ret2];
end proc;</Text-field></Input><Output><Text-field layout="Warning" style="Warning">Warning, `ret1` is implicitly declared local to procedure `H2`
</Text-field></Output><Output><Text-field layout="Warning" style="Warning">Warning, `ret2` is implicitly declared local to procedure `H2`
</Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSNIMkc2ImYqNiNJJHJlc0dGJTYoSSRpZTFHRiVJJnJlc2hpR0YlSSRpZTJHRiVJJnJlc2xvR0YlSSVyZXQxR0YlSSVyZXQyR0YlRiVGJUMpPjgkLUkrSUVFRWRvdWJsZUdGJTYjOSQ+OCUtSSZldmFsZkdJKnByb3RlY3RlZEdGOzYjKiYmRjI2IyIiIyIiIilGQCZGMjYjRkFGQT44KC1JKmllZWUyaGV4YUdGJTYjRjg+OCYtRjQ2IywmRjZGQUY4ISIiPjgnLUY6NiMqJiZGS0Y/RkEpRkAmRktGREZBPjgpLUZINiNGUTckRkZGWUYlRiVGJQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Une derni\350re proc\351dure pour \351crire les nombres SCS (floatant exacts) en hexad\351cimal dans un fichier ".h"</Font></Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle11" prompt="&gt; " style="ParagraphStyle2"><Font style="_cstyle5">Hexa_scs := proc (x) 
  local i, elem, mantisse, exposant, resultat; 
  global ulp, ulp_inv;
  if (x :: list) then
    [seq (Hexa(elem), elem=x)];
  else
    Digits := 60;
    if (x = 0)</Font><Font style="_cstyle6"> </Font><Font style="_cstyle5">then 
      resultat := 0;
    else
      exposant := floor(log[2](abs(evalf(x))));
      if (exposant &lt; -126) then exposant := -126; fi;
      resultat := round (ulp_inv * (abs(x) * 2^(-exposant) -1)) + ulp_inv / 2 * (exposant + 2^(lgex-1) - 1);
      if (x &lt; 0) then resultat := resultat + ulp_inv * 2^(lgex-1); fi; 
    fi;
  fi;
  convert(resultat, hex);
end:</Font><Font family="Lucida Bright">
</Font></Text-field></Input></Group><Group><Input><Text-field layout="_pstyle7" style="_cstyle57"> </Text-field><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Cette proc\351dure \351crit les coefficients d'un tableau dans un fichier au format hexadecimal</Font></Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">writtecoef:=proc(file, tab)
  local i, fd;
global deg;
  deg:= nops(tab);
#fclose(fd);
try
fd := fopen(file, WRITE, TEXT);
finally
fprintf(fd, "static const double constant_poly[%d]\n",deg);
for i from 1 to deg-1 do
  fprintf(fd,"/* ~%e, ~%e */ \n{", tab[i][1], tab[i][2]);
  fprintf(fd," { 0x%0.16s, 0x%0.16s }, \n", Hexa(tab[i][1]), Hexa(tab[i][2]));
od:
fprintf(fd,"/* ~%e, ~%e */ \n{", tab[deg][1], tab[deg][2]);
fprintf(fd," {0x%0.16s, 0x%0.16s}} \n",Hexa(tab[deg][1]), Hexa(tab[deg][2]));
fclose(fd);
end try;
end proc:  </Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">nops([Q]);
ta:=Q:
nops([ta]);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiY=</Equation></Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiY=</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_pstyle1"/></Input></Group><Text-field layout="_pstyle6" style="_pstyle6"/><Group><Input><Text-field layout="_pstyle6" style="_pstyle6"/><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">La proc\351dure  Ypol renvoie deux polynomes (Pinf et Psup) a partir de P, tels que P=Pinf+Psup et leurs coefficients sont repr\351sentables en machine.</Font></Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">Ypol:=proc(P)
local n, i, ci, cip, ciinf, cisup;
global Pinf, Psup;
n:=degree(P,x);
Pinf:=0; Psup:=0;
for i from 0 to n do
 ci:=coeff(P,x,i);
 cisup:=(IEEEdouble(ci))[2];
 cip:=ci-cisup;
 ciinf:=(IEEEdouble(cip))[2];
 Pinf:=Pinf+ciinf*x^i;
 Psup:=Psup+cisup*x^i;
od:
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">Ypol(Poly_Re):
Psup;Pinf;</Text-field></Input><Output><Text-field layout="Error" style="Error">Error, (in IEEEdouble) cannot determine if this expression is true or false: Poly_Re &lt; 0
</Text-field></Output><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiE=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiMiIiE=</Equation></Text-field></Output></Group><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">
La procedure pulp renvoie la precision de l'ulp du nombre x</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">pulp:=proc(x)
local flt, ulpy;
flt:=IEEEdouble(x);
ulpy:=-53+flt[1];
end proc;</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSVwdWxwRzYiZio2I0kieEdGJTYkSSRmbHRHRiVJJXVscHlHRiVGJUYlQyQ+OCQtSStJRUVFZG91YmxlR0YlNiM5JD44JSwmISNgIiIiJkYuNiNGN0Y3RiVGJUYl</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" style="Text">Computes the accumulated rounding error during the polynomial evaluation.
P is the polynomial.
xmax is the max value of x.
n is the degree when P is computed in double double.</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">read "Polylog.m";</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">ErrTruncPoly:=proc(poly,xmax, n)
local deg, delta, deltap, i, S, P, Smax:
deltap:=0:
delta:=0:
deg:=degree(poly):

S:=coeff(poly, x, deg):
Smax:=abs(S):

for i from (deg-1) to n by -1 do
  P:= convert(S*x, polynom):
  delta:= evalf(xmax*deltap + 2**(-53)*xmax*Smax):
      
  S:=convert(P+coeff(poly,x,i), polynom):
  Smax:=evalf(infnorm(S, x=-xmax..xmax)):
  deltap:= evalf(delta + 2**(-53)*(delta + Smax)):  
od:
for i from n-1 to 0 by -1 do
  P:= convert(S*x, polynom):
  delta:= evalf(xmax*deltap + 2**(-100)*xmax*Smax):
      
  S:=convert(P+coeff(poly,x,i), polynom):
  Smax:=evalf(infnorm(S, x=-xmax..xmax)):
  deltap:= evalf(delta + 2**(-100)*(delta + Smax)): 
od:
[deltap/Smax,log(deltap/Smax)/log(2.), log(deltap/Smax)/log(2.)+53];
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">ErrTruncPoly(P1,2**(-5),2);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3JSQiYXROKGU3WXpkM0xRWDxLWFZVJzMlZl51JilHWEMlZjtuLXJgYEFNKClwNVBOKXlOZVAyeChwW1soKVIhZS9mdSZlYkosaTNXJD5hPyIza3FmdEZaTCEkbyIkIWF0MD9pZENwRTVmWEs0J1IsX1peYiRmYVcnPnN4IVt2XlxHJj4pNFBrYitccSQpKjNoVzNhKDMqXFM5TFB4YSpHU2ZCLk54a1pXMjU7THFYT1BoISRbIiQhYHQwP2lkQ3BFNWZYSzQnUixfWl5iJGZhVyc+c3ghW3ZeXEcmPik0UGtiK1xxJCkqM2hXM2EoMypcUzlMUHhhKkdTZkIuTnhrWlcyNTtMcVhPUClGKQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" style="Text">Print a number x in Low or Big Endian representation in opened file "fd":</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">printendian:=proc(x,isbig,fd)
local xhl:
xhl:=ieee2Hexa(x):

if(isbig=0 or isbig=1) then
  fprintf(fd,"{{0x%+0.8s,0x%+0.8s}}, /* %+0.10f */\n"<Font opaque="false">, xhl[2-isbig]</Font>, xhl[isbig+1], x):
else
  print("ERROR, isbig must be equal to 0 or 1");
end if:
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">save nearest,IEEEdouble, poly_exact, poly_exact2, hi_lo, Hexa, ieee2Hexa, Hexa2ieee, H2, Hexa_scs, Ypol, writtecoef, pulp, ErrTruncPoly, printendian, "Common_maple_procedures.m"; </Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="_pstyle5"/></Input></Group></Section><Section><Title><Text-field layout="_pstyle12" style="_cstyle62">PARAMETERS:</Text-field></Title><Text-field layout="_pstyle7" style="_cstyle57"><Font encoding="ISO8859-1">Don\264t forget to set all the parameters here</Font></Text-field><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">NB_WORDS := 2:
NB_BITS  := 30:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="_pstyle12" style="_cstyle62">GetSCS_real</Text-field></Title><Text-field layout="_pstyle13" style="_cstyle63">This procedure convert a decimal number into it SCS representation.</Text-field><Text-field layout="_pstyle13" style="_cstyle63">       x : input number to convert into it SCS representation</Text-field><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">GetSCS_real := proc(x)
local exception, index, sign, mantissa, nb, i;

if x &lt;&gt; 0 then
  exception := 1;
  if x &gt; 0 then
    sign  := 1;
    nb    := x;
  elif x &lt; 0 then
    sign := -1;
    nb   := -x;
  end if;
  
  index := 0;

  if nb &gt;= 1 then
    for i from 0 while nb &gt; (2^(NB_BITS+1)-1) do
      index := index+1;
      nb    := nb * 2^(-NB_BITS);
    end do; 
  else
    for i from 0 while nb &lt; 1 do
      index := index-1;
      nb    := nb * 2^(NB_BITS);
    end do; 
  end if;

  for i from 0 by 1 to (NB_WORDS-1) do
    mantissa[i] := trunc(nb);
    nb          := (nb - mantissa[i]) * 2^(NB_BITS);
  end do;
else
  for i from 0 by 1 to (NB_WORDS-1) do
    mantissa[i] := 0;
  end do;

  index     := 1;
  exception := x;
  sign      := 1;
end if;
mantissa[NB_WORDS]   := exception;
mantissa[NB_WORDS+1] := index;
mantissa[NB_WORDS+2] := sign;

return mantissa;
end proc:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="_pstyle12" style="_cstyle62">SetSCS_real</Text-field></Title><Text-field layout="_pstyle7" style="_cstyle57">Convert an SCS number into a rational number</Text-field><Text-field layout="_pstyle6" style="_pstyle6"/><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">SetSCS_real := proc(tab)
  local res, i;

  if (tab[NB_WORDS] &lt;&gt; 1) then
    return tab[NB_WORDS];
  end if;

  res := 0;
  for i from (NB_WORDS-1) by -1 while i&gt;=0 do
    res := 2^(-NB_BITS)*res + tab[i] 
  end do;
  
res := tab[NB_WORDS+2]*(res * 2.^(NB_BITS * tab[NB_WORDS+1]));

return res;

end proc:
</Text-field></Input></Group><Text-field layout="_pstyle6" style="_pstyle6"/></Section><Section collapsed="true"><Title><Text-field layout="_pstyle12" style="_cstyle62">WriteSCS</Text-field></Title><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">Write Into file fd the SCSS number stored into the table tab where
tab[0..(NB_WORDS-1)] store the mantissa
tab[NB_WORDS] store the exception
tab[NB_WORDS+1] store the index
tab[NB_WORDS+2] store the sign
</Text-field><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">WriteSCS := proc(fd, tab)
 local i;

fprintf(fd,"{{");

fprintf(fd,"0x%+0.16x, ", tab[0]);
for i from 1 by 1 to (NB_WORDS-2) do
  fprintf(fd,"0x%+0.16x, ", tab[i]);
  if (i mod 4 = 3) then
    fprintf(fd,"\n"); 
  fi;
end do;
fprintf(fd,"0x%+0.16x},\n", tab[NB_WORDS-1]);
if (tab[NB_WORDS]=1) then
  fprintf(fd,"DB_ONE, %3d, %3d ", tab[NB_WORDS+1], tab[NB_WORDS+2]);
else
  # the only other possible value is 0 so ...
  fprintf(fd,"{0x00000000, 0x00000000}, %3d, %3d ", tab[NB_WORDS+1], tab[NB_WORDS+2]);
end if;

fprintf(fd, "} \n");
end proc:</Text-field></Input></Group></Section><Section><Title><Text-field layout="_pstyle12" style="_cstyle62">GetSCS_poly</Text-field></Title><Text-field layout="_pstyle6" style="_pstyle6"/><Group><Input><Text-field layout="_pstyle1" prompt="&gt; " style="_cstyle55">get_nb_terms := proc(poly)
 local i, deg_poly;

 deg_poly := degree(poly);
 for i from deg_poly by -1 while i&gt;=0 do
  if coeff(poly, x, i)=0 then
   deg_poly := deg_poly-1;
  end if;
 end do;

 return deg_poly;
end proc:</Text-field><Text-field layout="_pstyle6" prompt="&gt; " style="_pstyle6"/></Input></Group><Group><Input><Text-field layout="_pstyle7" style="_cstyle57">Convert each coefficient of a polynom into it SCSS representation

</Text-field><Text-field layout="_pstyle11" style="ParagraphStyle2"><Font style="_cstyle6">poly : input polynom 
  file : name of the file where to put the result</Font><Font style="_cstyle7">
GetSCS_poly := proc(poly, file)
  local i, fd, mantissa, deg;
  #fclose(fd);
  try
    fd := fopen(file, WRITE,TEXT);
  finally
    fprintf(fd,"static const SCS constant_poly[%d]=\n",get_nb_terms(poly)+1);
    deg := degree(poly); 

    fprintf(fd,"/* ~%e */ \n{", coeff(poly, x, deg));   
    mantissa := GetSCS_real(coeff(poly, x, deg));
    WriteSCS(fd, mantissa); 
    for i from (deg-1) by (-1) while i&gt;=0 do
      if (coeff(poly, x, i)&lt;&gt;0) then 
        fprintf(fd,",\n/* ~%e */ \n", coeff(poly, x, i));
        mantissa := GetSCS_real(coeff(poly, x, i));
        WriteSCS(fd, mantissa, 0);
      end if; 
    end do;
    fprintf(fd,"};\n");
   
  fclose(fd);
  end try;
end proc:</Font></Text-field></Input></Group><Group><Input><Text-field layout="_pstyle5" prompt="&gt; " style="Maple Input">GetSCS_poly(Poly_Re, "/home/cdaramy/polyhex_log.h");</Text-field></Input></Group></Section><Text-field layout="_pstyle14" style="_pstyle14"/><Text-field/><Section><Title><Text-field layout="Heading 1" style="Heading 1">Brouillon</Text-field></Title><Text-field/><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">nb:=12.0215;</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSNuYkc2IiQiJzotNyEiJQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">h,l:=hi_lo(nb);h;</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+NiRJImhHNiJJImxHRiY2JCMiMV5yX0s5diRRJCIwYzFyd1xaIkcjIjEwWCUqeigqKVJcKCJBO2dHXnMlUlVxO2wuJzRDRz8=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiMjIjFecl9LOXYkUSQiMGMxcndcWiJH</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">a:=ieee2Hexa(nb);ieee2Hexa(h);</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiM+SSJhRzYiNyRRKTQwMjgwQjAyRiVRKTBDNDlCQTVFRiU=</Equation></Text-field><Text-field layout="Maple Output" style="2D Output"><Equation>NiM3JFEpNDAyODBCMDI2IlEpMEM0OUJBNUVGJQ==</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">a[1];</Text-field></Input><Output><Text-field layout="Maple Output" style="2D Output"><Equation>NiNRKTQwMjgwQjAyNiI=</Equation></Text-field></Output></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Text-field/><Text-field/><Text-field/></Worksheet>
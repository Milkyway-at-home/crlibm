#######################################################################
# This file is part of the crlibm library, and is distributed under
# the  LGPL.
# To use:
# restart; read "exp-td.mpl";
Digits := 120:

interface(quiet=true):

read "common-procedures.mpl":
read "triple-double.mpl":

mkdir("TEMPPOW"):

# Some constants for special cases tests 

two52 := 2^(52):
two53 := 2^(53):
twoM53 := 2^(-53):
twoM54 := 2^(-54):
twoM1021 := 2^(-1021):
two1021 := 2^(1021):
twoM1000 := 2^(-1000):
two1000 := 2^(1000):
two999 := 2^(999):

scale := 2^(12):
rescale := 2^(-12):
shiftConst := 2^(52) + 2^(51):

largest := 2^(1023) * ((2^(53) - 1) / 2^(52)):
smallest := 2^(-1023) * 1 * 2^(-51):

# Logarithm log2_12 for power

L := 7: # number of bits used to address the table

MAXINDEX    := round(2^L * (sqrt(2)-1)):

for i from 0 to MAXINDEX-1 do
    center[i] := 1 + i*2^(-L): # center[i] in [1, 2[
    t :=  evalf(1/center[i]):
    r[i] := round(t * 2**(floor(-log[2](abs(t))) + 23)) / 2**(floor(-log[2](abs(t))) + 23):
    (logih[i], logil[i]) := hi_lo(evalf(-log[2](r[i]))):
od:
for i from MAXINDEX to 2^L do
    # y has been divided by two, center[i] in [0.5, 1[
    center[i]:=(1 + i*2^(-L)) / 2:
    t :=  evalf(1/center[i]):
    r[i] := round(t * 2**(floor(-log[2](abs(t))) + 23)) / 2**(floor(-log[2](abs(t))) + 23):
    (logih[i], logil[i]) := hi_lo(evalf(-log[2](r[i]))):
od:




#Computation of ZMax.
for i from 0 to MAXINDEX-1 do
    __x := center[i] + 2^(-L-1) :
    zmax[i] := (__x*r[i]-1) :
    __x := center[i] - 2^(-L-1) :
    zmin[i] := (__x*r[i]-1) :
od:
for i from MAXINDEX to 2^L do
    __x := center[i] + 2^(-L-2) :
    zmax[i] := (__x*r[i]-1) :
    __x := center[i] - 2^(-L-2) :
    zmin[i] := (__x*r[i]-1) :
od:

zmaxmax:=0:
zminmin:=0:
for i from 0 to 2^L do
    if zmax[i] > zmaxmax then zmaxmax := zmax[i]: fi:
    if zmin[i] < zminmin then zminmin := zmin[i]: fi:
od:
printf("zminmin = -2^(%2f)   zmaxmax = 2^(%2f)\n", log2(-zminmin), log2(zmaxmax) ):

pLogExact := unapply(-6497523352912697/36028797018963968*X^8+464105351149111/2251799813685248*X^7-4331547231022885/18014398509481984*X^6+324866042375467/1125899906842624*X^5-6497320848556805/18014398509481984*X^4+8460053188225/17592186044416*X^3-58522663504933901518104329421789/81129638414606681695789005144064*X^2+29261331752466950759073917813481/20282409603651670423947251286016*X,X):

pLog := poly_exact2(pLogExact(x),3):

epsLog := numapprox[infnorm](pLog/log[2](1+x)-1,x=zminmin..zmaxmax):

printf("Relative error of pLog w.r.t log2(1+x) is 2^(%f)\n",log[2](abs(epsLog))):


# Exponential exp2_12 for power 


for i from 0 to 2^6 - 1 do
	twoPowerIndex1hi[i], twoPowerIndex1lo[i] := hi_lo(evalf(2^(i/(2^6)))):
	twoPowerIndex2hi[i], twoPowerIndex2lo[i] := hi_lo(evalf(2^(i/(2^(12))))):
od: 

pExpExact := unapply(2772236920359585/288230376151711744*X^4+1999746284130149/36028797018963968*X^3+8655072057804175/36028797018963968*X^2+6243314768165359/9007199254740992*X+1,X):

pExp := poly_exact(pExpExact(x)):

epsExp := numapprox[infnorm]((pExp/2^x)-1,x=-2^(-12)..2^(-12)):

printf("Relative error of pExp w.r.t 2^x is 2^(%f)\n",log[2](abs(epsExp))):

log2 := nearest(log(2)):


# Overall accuracy estimate

# C'est pifometrique
epsOverall := 2^(-62):

bi := floor(-log[2](abs(epsOverall))):

approxBoundFactor := 2^(-(bi - 54)):


# Print out of the .h file 

filename:="TEMPPOW/pow.h":
fd:=fopen(filename, WRITE, TEXT):

fprintf(fd, "#include \"crlibm.h\"\n#include \"crlibm_private.h\"\n"):

fprintf(fd, "\n/*File generated by maple/pow.mpl*/\n"):

fprintf(fd, "\#define APPROXBOUNDFACTOR %1.50e\n", approxBoundFactor):   
fprintf(fd, "\#define TWO52 %1.50e\n", two52):   
fprintf(fd, "\#define TWO53 %1.50e\n", two53):   
fprintf(fd, "\#define TWOM53 %1.50e\n", twoM53):   
fprintf(fd, "\#define TWOM54 %1.50e\n", twoM54):   
fprintf(fd, "\#define TWOM1021 %1.50e\n", twoM1021):   
fprintf(fd, "\#define TWO1021 %1.50e\n", two1021):   
fprintf(fd, "\#define TWOM1000 %1.50e\n", twoM1000):   
fprintf(fd, "\#define TWO999 %1.50e\n", two999):   
fprintf(fd, "\#define TWO1000 %1.50e\n\n", two1000):   
fprintf(fd, "\#define SCALE %1.50e\n", scale):   
fprintf(fd, "\#define RESCALE %1.50e\n", rescale):   
fprintf(fd, "\#define SHIFTCONSTANT %1.50e\n", shiftConst):   
fprintf(fd, "\#define LARGEST %1.50e\n",largest):
fprintf(fd, "\#define SMALLEST %1.50e\n\n",smallest):


(log2coeff1dh,log2coeff1dl) := hi_lo(coeff(pLog,x,1)):
(log2coeff2dh,log2coeff2dl) := hi_lo(coeff(pLog,x,2)):
fprintf(fd, "\#define log2coeff1h %1.50e\n",log2coeff1dh):	
fprintf(fd, "\#define log2coeff1l %1.50e\n",log2coeff1dl):	
fprintf(fd, "\#define log2coeff2h %1.50e\n",log2coeff2dh):	
fprintf(fd, "\#define log2coeff2l %1.50e\n",log2coeff2dl):	
for i from 3 to 8 do
	fprintf(fd, "\#define log2coeff%d %1.50e\n",i,coeff(pLog,x,i)):
od:
fprintf(fd,"\n"):

for i from 1 to 4 do
	fprintf(fd, "\#define exp2coeff%d %1.50e\n",i,coeff(pExp,x,i)):
od:
fprintf(fd,"\n"):

fprintf(fd, "\#define LOG2 %1.50e\n\n", log2):   

fprintf(fd, "typedef struct rri_tag {float ri; double logih; double logil;} rri;  \n"):
fprintf(fd, "static const rri argredtable[%d] = {\n", 2^L):
for i from 0 to 2^L-1 do
      fprintf(fd, "  { \n"):
      fprintf(fd, "    %1.50e,   /* r[%d] */ \n", r[i], i):
      fprintf(fd, "    %1.50e, /* logih[%d] */ \n", logih[i], i):
      fprintf(fd, "    %1.50e, /* logil[%d] */ \n", logil[i], i):
      fprintf(fd, "  } "):
      if(i<2^L-1) then  fprintf(fd, ", \n"): fi
od:
fprintf(fd, "}; \n \n"):

fprintf(fd, "typedef struct tPi_t_tag {double hi; double lo;} tPi_t;  \n"):
fprintf(fd, "static const tPi_t twoPowerIndex1[%d] = {\n", 2^(6)):
for i from 0 to 2^(6)-1 do
      fprintf(fd, "  { \n"):      
      fprintf(fd, "    %1.50e, /* twoPowerIndex1hi[%d] */ \n", twoPowerIndex1hi[i], i):
      fprintf(fd, "    %1.50e, /* twoPowerIndex1lo[%d] */ \n", twoPowerIndex1lo[i], i):
      fprintf(fd, "  } "):
      if(i<2^(6)-1) then  fprintf(fd, ", \n"): fi
od:
fprintf(fd, "}; \n \n"):
fprintf(fd, "static const tPi_t twoPowerIndex2[%d] = {\n", 2^(6)):
for i from 0 to 2^(6)-1 do
      fprintf(fd, "  { \n"):      
      fprintf(fd, "    %1.50e, /* twoPowerIndex2hi[%d] */ \n", twoPowerIndex2hi[i], i):
      fprintf(fd, "    %1.50e, /* twoPowerIndex2lo[%d] */ \n", twoPowerIndex2lo[i], i):
      fprintf(fd, "  } "):
      if(i<2^(6)-1) then  fprintf(fd, ", \n"): fi
od:
fprintf(fd, "}; \n \n"):





fclose(fd):

printf("--------- DONE -----------\n");
<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="0"/><View-Properties><Zoom percentage="100"/></View-Properties><Styles><Layout alignment="left" bullet="none" name="Heading 2" spaceabove="8.0" spacebelow="2.0"/><Layout alignment="left" bullet="none" name="Heading 1" spaceabove="8.0" spacebelow="4.0"/><Layout leftmargin="0.0" name="_pstyle47" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle42" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle41" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle82" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle81" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle80" rightmargin="0.0"/><Layout leftmargin="0.0" name="Normal" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle36" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle35" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle33" rightmargin="0.0"/><Layout leftmargin="0.0" name="_pstyle32" rightmargin="0.0"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" name="_cstyle16" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" name="_cstyle14" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle13" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" name="_cstyle10" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="Text" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" name="ParagraphStyle8" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" bold="true" family="Serif" name="Heading 2" opaque="false" size="16"/><Font background="[0,0,0]" bold="true" family="Serif" name="Heading 1" opaque="false" size="18"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_pstyle42" readonly="false"/><Font background="[0,0,0]" bold="false" executable="false" family="Lucida Bright" foreground="[0,0,0]" italic="false" name="_pstyle80" readonly="false" size="12" underline="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="Page Number" readonly="false" underline="false"/><Font background="[0,0,0]" executable="false" family="Lucida Bright" name="_cstyle494" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_cstyle492" readonly="false"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="_pstyle33" readonly="false"/></Styles><Page-Numbers enabled="false" first-number="1" first-numbered-page="1" horizontal-location="right" style="Page Number" vertical-location="bottom"/><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">restart:
Digits := 100:</Text-field></Input><Input><Text-field layout="_pstyle33" prompt="&gt; " style="_pstyle33">with (numapprox):<Font italic="false" size="12" underline="false">with(orthopoly):</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">read "Common_maple_procedures.m";
mkdir("TEMPLOG");
deg:=12;</Text-field></Input></Group><Section><Title><Text-field layout="Heading 1" style="Heading 1">First, quick phase</Text-field></Title><Text-field layout="Normal" style="Text"/><Group><Input><Text-field layout="Normal" style="Text">Approach for the first function:</Text-field><Text-field layout="Normal" style="Text">log(x) = E*log(2) + P(R)
where P(R) is defined over such an interval [11/16; 12/16] ... [21/16; 23/16]
At all, there is 8 intervals, corresponding to 8 polynomials.</Text-field></Input><Input><Text-field layout="Normal" style="Text"/></Input></Group><Section collapsed="true"><Title><Text-field layout="Heading 2" style="Heading 2">Interval parameters</Text-field></Title><Text-field layout="Normal" style="Text"/><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Xmax:=[2**(-5), 2**(-5), 2**(-5), 2**(-5), 2**(-4), 2**(-4), 2**(-4), 2**(-4)]:
Ilist:=[[11/16,12/16],[12/16,13/16],[13/16,14/16],[14/16,15/16],[15/16,17/16],[17/16,19/16],[19/16,21/16],[21/16,23/16]]:
midI:=[23/32,25/32,27/32,29/32,1,18/16,20/16,22/16]:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">save Xmax, Ilist, midI, "TEMPLOG/parameterlog.m";</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="Heading 2" style="Heading 2">Computation of the polynomials</Text-field></Title><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" style="Text">This is the function we use on all the intervals except i=5 (the one around 1)</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">poly_log_2 := proc(i,deg) 
 local p, e, pt, rel_approx_error, abs_rounding_error, minptr, maxptr, maxpt, delta, miny, deltaZero, deltaEgt24 ;

  pt, rel_approx_error,  maxpt := poly_trunc_f2d_2( log(x+midI[i]) ,  deg, -Xmax[i], Xmax[i]):

  abs_rounding_error, minptr, maxptr := compute_abs_rounding_error(pt, Xmax[i], 2):

  printf("Interval %d  : minp,maxp=(%3.2f,%3.2f)  rel. approx err. = %3.2f bits, abs_round. err. = %3.2f",
    i, minptr, maxptr,  -log2(rel_approx_error), -log2(abs_rounding_error) ):

  # delta for E&lt;&gt;0
  miny:=nearest(log(2)) - maxptr;
  delta := (rel_approx_error*maxptr + abs_rounding_error)/miny * (1+2^(-100)):

  #delta for E&gt;=24
  miny:=nearest(24*log(2)) - maxptr;
  deltaEgt24 := (1 + (rel_approx_error*maxptr + abs_rounding_error)/miny) * (1+2^(-100)) - 1:

  #delta for E=0
  abs_rounding_error, minptr, maxptr := compute_abs_rounding_error_firstmult(pt, Xmax[i], 2):
  deltaZero := (rel_approx_error*maxptr + abs_rounding_error)/minptr: 

  printf("  delta = %3.2f,   deltaZero = %3.2f,   deltaEgt24 = %3.2f\n",
        -log2(delta), -log2(deltaZero), -log2(deltaEgt24) );

  [pt, max(maxpt,maxptr), delta, deltaZero, deltaEgt24]
end proc:</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">evalf(24*log(2));</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"/></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Special case around one</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">i:=5:
xmax5:=Xmax[i]:
pe5:=minimax(  (log(1+x)/x),  x=-xmax5..xmax5,  [deg-1,0], 1 ,  'err'):
pe5:=pe5*x:
pt5 := poly_exact2( pe5, 2):
rept5 := infnorm( 1-pt5/log(1+x), x=-xmax5..xmax5):
maxpt5:= infnorm( pt5, x=-xmax5..xmax5):

# the relative error in the case when E&lt;&gt;0
abs_rounding_error5, minptr5, maxptr5 :=compute_abs_rounding_error(pt5, xmax5, 2):
min_y5 := nearest(log(2)) - maxptr5:
delta5 := (rept5*maxptr5 + abs_rounding_error5)/min_y5 * (1+2^(-100)): 

printf("Interval %d  : minp,maxp=(%3.2f,%3.2f)  rel. approx err. = %3.2f bits, abs_round. err. = %3.2f",
    i, minptr5, maxptr5,  -log2(rept5), -log2(abs_rounding_error5) ):
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  #delta for E&gt;=24
  miny5:=nearest(24*log(2)) - maxptr5;
  deltaEgt245 := (1 + (rept5*maxptr5 + abs_rounding_error5)/miny5) * (1+2^(-100)) - 1;

# the relative error in the case when E=0
deltaZero5 := (1+rept5)  * (1 + compute_rel_rounding_error_firstmult(pt5,xmax5, 2)) - 1 ;
printf("  delta = %3.2f,   deltaZero = %3.2f,   deltaEgt24 = %3.2f\n",
        -log2(delta5), -log2(deltaZero5), -log2(deltaEgt245) );
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">evalf(compute_rn_constant(deltaZero5));</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">The warning above is OK, because the Add22 in question adds zero, which is an exact operation even with the unconditional version.</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">PolyList:=[ 
  poly_log_2(1,deg),
  poly_log_2(2,deg),
  poly_log_2(3,deg),
  poly_log_2(4,deg),
  [pt5,maxptr5,delta5,deltaZero5,deltaEgt245],
  poly_log_2(6,deg),
  poly_log_2(7,deg),
  poly_log_2(8,deg)
]:  </Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">save PolyList, "TEMPLOG/PolyList.m";</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" linespacing="0.0" rightmargin="0.0" style="Heading 2">Computation of constants for RN test</Text-field></Title><Group><Input><Text-field layout="Normal" style="Text">We have in PolyList delta the total error for polynomial approximation, build tabrndcst[] the table of "e" needed for round to nearest</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">read "TEMPLOG/PolyList.m"; read "TEMPLOG/parameterlog.m";</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">maxdelta:=0:
maxdeltaEZero:=0:
maxdeltaEgt24:=0:

for i from 1 to 8 do
  delta:=PolyList[i][3];
  deltaEZero:=PolyList[i][4]:
  deltaEgt24:=PolyList[i][5]:
  if delta &gt; maxdelta then maxdelta := delta : fi :
  if deltaEZero &gt; maxdeltaEZero then maxdeltaEZero := deltaEZero : fi :
  if deltaEgt24 &gt; maxdeltaEgt24 then maxdeltaEgt24 := deltaEgt24 : fi :
od:
rncst := evalf(compute_rn_constant(maxdelta));
rncstEZero := evalf(compute_rn_constant(maxdeltaEZero));
rncstEgt24 := evalf(compute_rn_constant(maxdeltaEgt24));

</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Compute the total rel error in Fast path</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">max_abs_err:=0:
for i from 1 to 8 do
  xmax:=Xmax[i];
  p:=poly_exact2(PolyList[i][1],1):
  pmax:=PolyList[i][2]:
  abs_appr_err:=infnorm(p-log(x+midI[i]),x=-xmax..xmax):
  abs_rnd_err,miny,maxy := compute_abs_rounding_error(p,xmax, 1);
  abs_err := abs_appr_err + abs_rnd_err + 2^(-90);
  if abs_err &gt; max_abs_err then max_abs_err := abs_err: fi:
  printf(" (appr %3.4f, rnd %3.4f), total %3.4f", log2(abs_appr_err), log2(abs_rnd_err),  log2(abs_err));
od:
log2(max_abs_err);</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Try doubling and halving minfastpath. This value is optimal for the Pentium IV</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">minfastpath:=128+0.5;
deltafastpath:=max_abs_err/(minfastpath-0.4);
log2(deltafastpath);
rncstfastpath := evalf(compute_rn_constant(deltafastpath));</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text">Also tested with one iteration less, but it is too much worse</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
for i from 1 to 8 do
  xmax:=Xmax[i];
  p:=poly_exact(PolyList[i][1]):
  p:= p - (coeff(p,x,12)*x^12) ;
  rel_appr_err:=infnorm(1-p/log(x+midI[i]),x=-xmax..xmax):
  rel_rnd_err := compute_rel_rounding_error(p,xmax, 0);
  rel_err := (1+rel_appr_err) * (1+rel_rnd_err) * (1 + 2^(-100) ) - 1:
  printf("%3.4f (appr %3.4f, rnd %3.4f)\n", log2(rel_err), log2(rel_appr_err), log2(rel_rnd_err) );
od:</Text-field></Input></Group></Section><Section collapsed="true"><Title><Text-field layout="Heading 2" style="Heading 2">Output</Text-field></Title><Group><Input><Text-field layout="_pstyle47" prompt="&gt; " style="_cstyle16"/></Input></Group><Group><Input><Text-field layout="_pstyle35" style="Text"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">filename:="TEMPLOG/log_fast.h":
fd:=fopen(filename, WRITE, TEXT):

fprintf(fd, "#include \"crlibm.h\"\n#include \"crlibm_private.h\"\n"):

fprintf(fd, "\n/*File generated by maple/coef_log.mw*/\n"):

fprintf(fd, "\n\#define SQRT_2 1.4142135623730950489e0 \n\n"):
fprintf(fd, "\n#ifdef WORDS_BIGENDIAN\n"):
fprintf(fd, "\db_number const ln2hi = {{0x3FE62E42, 0xFEFA39EF}};\n"):
fprintf(fd, "db_number const ln2lo = {{0x3C7ABC9E, 0x3B39803F}};\n"):
fprintf(fd, "db_number const two52 = {{0x43300000, 0x00000000}};\n"):
fprintf(fd, "#else\ndb_number const ln2hi = {{0xFEFA39EF, 0x3FE62E42}};\n"):
fprintf(fd, "db_number const ln2lo = {{0x3B39803F, 0x3C7ABC9E}};\n"):
fprintf(fd, "db_number const two52 = {{0x00000000, 0x43300000}};\n"):
fprintf(fd, "#endif\n\n"):

fprintf(fd, "#define DEGREE %d\n\n", deg):

fprintf(fd,"#define MIN_FASTPATH %4.3f \n",minfastpath ):

fprintf(fd,"/* Constants for rounding  */\n"):

fprintf(fd,"double const delta[4] =\n{\n"):
fprintf(fd,"  /* Case E=0  */\n"):
fprintf(fd,"  %1.50e, \n",maxdeltaEZero):
fprintf(fd,"  /* Middle case   */\n"):
fprintf(fd,"  %1.50e, \n",maxdelta):
fprintf(fd,"  /* Case E&gt;24  */\n"):
fprintf(fd,"  %1.50e, \n",maxdeltaEgt24):
fprintf(fd,"  /* And for the fast path  */\n"):
fprintf(fd,"  %1.50e \n",deltafastpath):
fprintf(fd,"\n};\n\n"):

fprintf(fd,"double const rncst[4] =\n{\n"):
fprintf(fd,"  /* Case E=0  */\n"):
fprintf(fd,"  %1.50e, \n",rncstEZero):
fprintf(fd,"  /* Middle case   */\n"):
fprintf(fd,"  %1.50e, \n",rncst):
fprintf(fd,"  /* Case E&gt;24  */\n"):
fprintf(fd,"  %1.50e, \n",rncstEgt24):
fprintf(fd,"  /* And for the fast path  */\n"):
fprintf(fd,"  %1.50e \n",rncstfastpath):
fprintf(fd,"};\n\n"):


# THE POLYNOMIALS

npol:=8: 
n:=2:  # the degree from which we want two doubles

fprintf(fd,"#ifdef WORDS_BIGENDIAN\n"):
for isbig from 1 to 0 by -1 do

  if(isbig=0) then
    fprintf(fd,"#else\n"):
  fi;

  # Write middle table

  fprintf(fd, "db_number const middle[%d] =\n{\n",npol):
  for i from 1 to 7 do
    printendian(fd,midI[i],isbig);
    fprintf(fd," ,\n"):
  od:
  printendian(fd,midI[8],isbig):
  fprintf(fd, "\n};\n\n"):

  #Write Poly_h

  fprintf(fd,"db_number const Poly_h[%d][%d] =\n{\n", npol, deg+1):
  for k from 1 to 8 do<Font italic="false" size="12" underline="false">
    fprintf(fd," /* polynomial %d */\n",k):</Font>
    fprintf(fd,"{\n");
    P:=PolyList[k][1]:
    for j from 0 to deg do<Font italic="false" size="12" underline="false">
      coef:=hi_lo(coeff(P,x,j)):</Font>
      printendian(fd, coef[1], isbig):
      if j&lt;deg then fprintf(fd," ,\n") fi:
    od:
    fprintf(fd, "\n}"):
    if k&lt;8 then fprintf(fd, ",\n") fi:
  od: 

  fprintf(fd, "\n};\n\n"):

  #Write Poly_fast_l

  fprintf(fd,"db_number const Poly_l[%d][%d] =\n{\n",8,n):
  for k from 1 to 8 do
    fprintf(fd," /* polynomial %d */\n",k):
    fprintf(fd,"{\n");
    P:=PolyList[k][1]:
    for j from 0 to n-1 do
      coef:=hi_lo(coeff(P,x,j)):
      printendian(fd, coef[2], isbig):
      if j&lt;deg then fprintf(fd," ,\n") fi:
    od:
    fprintf(fd, "\n}"):
    if k&lt;8 then fprintf(fd, ",\n") fi:
  od:
  fprintf(fd,"\n};\n\n"):

od:
fprintf(fd,"#endif\n\n\n"):



fclose(fd):
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 2" leftmargin="0.0" linespacing="0.0" rightmargin="0.0" style="Heading 2"><Font executable="false" foreground="[0,0,0]" italic="false" underline="false">Debugging help</Font></Text-field></Title><Group><Input><Text-field layout="_pstyle36" prompt="&gt; " style="_cstyle10">read "parameterlog.m";
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">read "procedures.m";
read "Polylog.m";</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle35" style="Text">Valeurs du debuggueur</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle47" prompt="&gt; " style="_cstyle16">debug1:=hexa2ieee(["3ff1078f","1da3ee1b"]):
debug2:=hexa2ieee(["3ff11adb","35a43279"]):
debug3:=hexa2ieee(["3ff2f3dd","5f33e4ad"]):
debug4:=hexa2ieee(["3ff2fa98","c7deeb8e"]):
debug5:=hexa2ieee(["4002fe57","89bc59a6"]):</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle80" style="_pstyle80"><Font encoding="ISO8859-1">R\351alise le calcul du polynome tel qu'il est calcul\351 sur ordinateur : param\350tres d'entr\351e, variable enter et entier i.. </Font>
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle81" prompt="&gt; " style="ParagraphStyle8"><Font style="_cstyle14">compaccuracy:=proc(enter, i)
local pol, Expo, nb, nb2, res, Ph, Pl, reshi, reslo, resfinal:
global midI, Plist:

pol:=Plist[i+1]:
Expo:=trunc(log(enter)/log(2.));
nb:=enter/(2**(Expo)):
if(nb&gt;evalf(sqrt(2))) then 
  Expo:= Expo +1;
  nb:= nb/2. ;
fi;
nb2:= nb - midI[i+1]:
print(nb2);

res:=coeff(pol,x,13):
for j from 12 to 2 by -1 do
  res := nearest(res*nb2):
  res :=nearest(res+coeff(pol,x,j)):
od:

Ph,Pl:=hi_lo(res*nb2):
print(ieee2hexa(Ph));

reshi,reslo:=hi_lo(Ph+Pl + coeff(pol,x,1)):
print(ieee2hexa(reshi));

Ph,Pl:=hi_lo((reshi+reslo)*nb2):
print(ieee2hexa(Ph));

reshi,reslo:=hi_lo(Ph+Pl + coeff(pol,x,0)):
print(ieee2hexa(reshi));</Font><Font italic="false" size="12" style="_cstyle13" underline="false">

resfinal:=evalf(hi_lo(reshi+reslo+Expo*log(2.)));
ieee2hexa(resfinal);</Font>
end proc;</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compaccuracy(debug2,4);</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="_pstyle80" style="_pstyle80"><Font encoding="ISO8859-1">Proc\351dure qui calcule le r\351sultat du polyn\364me en pr\351cision infinie avec arrondi IEEE \340 la fin:</Font>
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle82" prompt="&gt; " style="_cstyle14">infaccuracy:=proc(enter, i)
local pol, Expo, nb, nb2, res, resfinal:
global midI, Plist:

pol:=Plist[i+1]:
Expo:=trunc(log(enter)/log(2.)):
nb:=enter/(2**Expo):
if(nb &gt; evalf(sqrt(2))) then 
  Expo:= Expo +1;
  nb:= nb/2. ;
fi;
nb2:= nb - midI[i+1];
ieee2hexa(nb2);

res:=coeff(pol,x,14):

for j from 13 to 0 by -1 do
  res := res*nb2:
  res := res + coeff(pol,x,j):
od:
res;
print(ieee2hexa(res));

resfinal:= evalf(Expo*log(2.)+res);
print(ieee2hexa(resfinal));
end proc;</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">infaccuracy(debug2, 4);</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle35" style="Text">Calcul de la fonction log de maple:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle47" prompt="&gt; " style="_cstyle16">ieee2hexa(evalf(log(debug2)));
</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section></Section><Section collapsed="true"><Title><Text-field layout="Heading 1" style="Heading 1">Second, accurate phase in SCS</Text-field></Title><Group><Input><Text-field layout="_pstyle41" style="_cstyle494">Approach for the scs function:</Text-field><Text-field layout="_pstyle42" style="_pstyle42"/><Text-field layout="_pstyle41" style="_cstyle494"> x=2^e (1+f)
 log(x) = e.log(2) + log(1+f)

  log(1+f) = log(w) + log(1+(1+f-w)/w)
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">W := 2^5:</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">Poly_P := series((ln(1+x)/ln(2.))/x, x=0, 45):
Poly_Q := convert(Poly_P,polynom):</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">Poly_cheb := chebpade(Poly_Q, x=-1/W..1/W, [19,0]):</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">Poly_Res  := sort(expand(x * Poly_cheb)):</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">log2(infnorm((1-(expand(Poly_Res))/(ln(1+x)/ln(2.))), x=-1/W..1/W));</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle41" style="_cstyle494">This procedure gives under a polynom form value needed by tabular range reduction for the logarithm.
DON'T forget the zero !!!!
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle32" prompt="&gt; " style="_cstyle492">Digits       := 50:  
table_ti     := 0:
table_inv_wi := 0:
N            := -4:   
break_point  := sqrt(2.):
start_nb     := round((break_point/2) * 2.^(-N))*2.^(N):
nb_turn      := round((break_point/2) * 2.^(-N)): 

for i from 0 to nb_turn do
   table_ti := table_ti * x + log(start_nb):
   table_inv_wi := table_inv_wi *x + 1./ start_nb:
   start_nb := start_nb + 2.^(N):
od:</Text-field></Input></Group></Section><Text-field/><Section collapsed="true"><Title><Text-field firstindent="0.0" layout="Heading 1" leftmargin="0.0" linespacing="0.0" rightmargin="0.0" style="Heading 1">Tests and scratch</Text-field></Title><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group></Section><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/></Worksheet>
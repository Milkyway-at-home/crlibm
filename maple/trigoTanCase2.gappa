# Usage: You need to replace a few constants (beginning by _) by numerical
# values. Running the trigo.mpl Maple script will generate a
# TEMPTRIG/tanCase2.sed sed script that does it.
# Then sed -f TEMPTRIG/TanCase2.sed trigoTanCase2.gappa | gappa  > /dev/null


# NOTATION CONVENTION 
# Variables that correspond to double-precision variables in the code begin with a small letter
# Other variables begin with a capital letter.
# Otherwise avoid underscores as they are painful to carry on to LaTeX :)



# Definition of the polynomial constants:
t11 = _t11;
t9  = _t9;
t7  = _t7;
t5  = _t5;
t3h = _t3h;
t3l = _t3l;

#######################################################################

# First, a transcription of the actual computation, which could (and
# should eventually) be generated automatically from the actual code

# ---------------------Code cut from tan_rn : 
#    x2 = x*x;
x2 = <float64ne>(x * x);
X2 = x*x;

#    p5 = t5 + x2*(t7 + x2*(t9 + x2*(t11 + x2*(t13 + x2*t15))));
p5 = <float64ne>(t5 + <float64ne>(x2*<float64ne>(t7 + <float64ne>(x2*<float64ne>(t9 + <float64ne>(x2*t11))))));
P5 = t5 + X2*(t7 + X2*(t9 + X2*t11));

#    tt = x2*(t3h + (t3l +x2*p5));
tt = <float64ne>(x2*<float64ne>(t3h + <float64ne>(t3l +<float64ne>(x2*p5))));
Tt = X2*(t3h + (t3l + X2*p5));

#    Add12(rri.rh, rri.rl, x, x*tt);   
rdd = x + <float64ne>(x*tt);  # The Add12 is exact

Poly = x+x*Tt;

epsilon=(rdd - TanX)/TanX;

{
# Je veux au final:    x in [1b-30, _xmax]

# HELP: essaye toi-meme les trois lignes suivantes; Les deux premieres
# passent, la troisieme pas, alors que sauf ivrognerie de ma part
# c'est l'union des intervalles. voir HINT LOUCHE ci-dessous

#    x in [1b-6, 1b-5]
#    x in [1b-7, 1b-6]
#
    x in [1b-7, 1b-5]

 /\ (Poly - TanX)/TanX in [-_maxEpsApprox, _maxEpsApprox]
 /\ ((Poly - TanX)/TanX)/x in [-_maxEpsApproxOverX, _maxEpsApproxOverX]

->  

epsilon in ?
/\
epsilon/x in  [-1b-56,1b-56] # c'est vraiment cela que je veux prouver. Je m'en fous d'un encadrement plus fin
 

#/\
#(rdd - Poly)/Poly in ?
#/\
#(Poly - TanX)/TanX in ?
#/\
#(rdd-x)/x in ?
#/\
#(<float64ne>(x*tt) - x*Tt) / x in ?
#/\
# ((<float64ne>(x*tt) - x*tt)/(x*tt)) * tt in ?
#/\
#(tt - Tt) in ?
}

# HELP : sur quelle requete faut-il mettre le $ au juste ? 
epsilon/x $ x;

# Hint louche: c'est le tien mais j'ai ajoute /x*x   pour qu'il utilise l'encadrement fait par Maple
(rdd - TanX)/TanX -> (rdd - Poly)/Poly  + (((Poly - TanX)/TanX)/x)*x + ((rdd - Poly)/Poly) * ((Poly - TanX)/TanX) ; 

(rdd - Poly)/Poly  ->  ((<float64ne>(x*tt) - x*Tt) / x) * (x/Poly);

# "a verifier soigneusement" -- ameliore un peu le resultat mais bon...
(<float64ne>(x*tt) - x*Tt)/x -> ((<float64ne>(x*tt) - x*tt)/(x*tt)) * tt   +  (tt - Tt);  

# C'est un peu etrange d'avoir a donner ceux-ci, non ?
x/Poly -> 1/(Poly/x);
Poly/x -> 1+Tt;



# Usage: You need to replace a few constants (beginning by _) by numerical
# values. Running the trigo.mpl Maple script will generate a
# TEMPTRIG/tanCase2.sed sed script that does it.
# Then sed -f TEMPTRIG/TanCase2.sed trigoTanCase2.gappa | gappa  > /dev/null


# NOTATION CONVENTION 
# Variables that correspond to double-precision variables in the code begin with a small letter
# Other variables begin with a capital letter.
# Otherwise avoid underscores as they are painful to carry on to LaTeX :)



# Definition of the polynomial constants:
t11 = _t11;
t9  = _t9;
t7  = _t7;
t5  = _t5;
t3h = _t3h;
t3l = _t3l;

#######################################################################

# First, a transcription of the actual computation, which could (and
# should eventually) be generated automatically from the actual code

# ---------------------Code cut from tan_rn : 
#    x2 = x*x;
x2 = <float64ne>(x * x);
X2 = x*x;

#    p5 = t5 + x2*(t7 + x2*(t9 + x2*(t11 + x2*(t13 + x2*t15))));
p5 = <float64ne>(t5 + <float64ne>(x2*<float64ne>(t7 + <float64ne>(x2*<float64ne>(t9 + <float64ne>(x2*t11))))));
P5 = t5 + X2*(t7 + X2*(t9 + X2*t11));

#    tt = x2*(t3h + (t3l +x2*p5));
tt = <float64ne>(x2*<float64ne>(t3h + <float64ne>(t3l +<float64ne>(x2*p5))));
Tt = X2*(t3h + (t3l + X2*p5));

#    Add12(rri.rh, rri.rl, x, x*tt);   
rdd = x + <float64ne>(x*tt);  # The Add12 is exact

Poly = x+x*Tt;

epsilon=(rdd - TanX)/TanX;

{
# Je veux au final:    x in [1b-30, _XMAX]
# En attendant je mets, en faisant confiance a la monotonicite...
    x in [3b-6, _XMAX]
 /\ (Poly - TanX)/TanX in [-_MAXEPSAPPROX, _MAXEPSAPPROX]

->  

epsilon in ?
/\
epsilon/x in ?
 

#/\
#(rdd - Poly)/Poly in ?
#/\
#(Poly - TanX)/TanX in ?
#/\
#(rdd-x)/x in ?
#/\
#(<float64ne>(x*tt) - x*Tt) / x in ?
#/\
# ((<float64ne>(x*tt) - x*tt)/(x*tt)) * tt in ?
#/\
#(tt - Tt) in ?
}

# HELP ici
epsilon/x $ x;

#(rdd - TanX)/TanX -> (rdd - Poly)/TanX  + (Poly - TanX)/TanX ; 
(rdd - TanX)/TanX -> (rdd - Poly)/Poly  + (Poly - TanX)/TanX + ((rdd - Poly)/Poly) * ((Poly - TanX)/TanX) ; 

(rdd - Poly)/Poly  ->  ((<float64ne>(x*tt) - x*Tt) / x) * (x/Poly);

# " a verifier soigneusement -- ameliore un peu le resultat"
(<float64ne>(x*tt) - x*Tt)/x -> ((<float64ne>(x*tt) - x*tt)/(x*tt)) * tt   +  (tt - Tt);  

# C'est un peu etrange d'avoir a donner ceux--ci mais bon.
x/Poly -> 1/(Poly/x);
Poly/x -> 1+Tt;



# Usage: You need to set the constants. Running the log-de.mpl Maple script
# should create the required sed files.  The command to run is 
#  sed -f  TEMPLOG/log-de_0.sed log-de-E0-logir0.gappa | gappa > /dev/null

# NOTATION CONVENTION 
# Variables that correspond to double-precision variables in the code begin with a small letter
# Other variables begin with a capital letter.
# Variables that will be replaced with Maple-computed constants begin with an underscore
# Otherwise avoid underscores as they are painful to carry on to LaTeX :)

# polynomial coefficients, computed by Maple
c1 = _c1;
c2 = _c2;
c3 = _c3;
c4 = _c4;
c5 = _c5;
c6 = _c6;
c7 = _c7;
log2h  = _log2h;
log2l  = _log2l;

# Transcription of the code, NOT using FMA
z2  <float80ne>= z*z;    
p67 <float80ne>= c6 + z*c7;       
p45 <float80ne>= c4 + z*c5;      
p23 <float80ne>= c2 + z*c3;    
z4  <float80ne>= z2*z2;  
p47 <float80ne>= p45 + z2*p67;    
p03 <float80ne>= z + z2*p23; 
log <float80ne>= p03 + z4*p47;


# Give the polynomial in Estrin form (no need to transcribe the intermediate steps)
# Since the argument reduction is exact, z=Z.
Z2 = z*z;
Z4 = Z2*Z2;
Z3 = z*z*z; # to lighten the hints

P23 = (c2+z*c3);
P47 = (c4 + z*c5) + Z2*(c6 + z*c7);
P03 = z + Z2*P23;
AP03    = z + Z2*p23;
AP03R0  = z + z2*p23;
AP03R1  = z+<float80ne>(z2*p23);
# AP03R2 = p03

PolyLog1pz = P03  + Z4*P47  ;

# PolyLog1pz = P03 + Z4*P47,   with the differential between p47 and P47 managed below
LogR = p03 + Z4*p47;
LogR0 = p03 + z4*p47;
LogR1 = p03 + <float80ne>(z4*p47);
# LogR2 = log

{
    z in [-_zmax, _zmax] 
/\  (PolyLog1pz - Log)/Log in [-_epsilonApproxQuick, _epsilonApproxQuick]

->

(log - Log)/Log in  [-1b-61, 1b-61]
}

#  the obvious decomposition of (log-Log)/Log:
(log-Log)/Log -> (log - PolyLog1pz)/PolyLog1pz + (PolyLog1pz - Log)/Log   +   ((log - PolyLog1pz)/PolyLog1pz) * ((PolyLog1pz - Log)/Log);

# Intermediate steps for epsilon(log,PolyLog1pz) 
(log - PolyLog1pz)/PolyLog1pz   -> (log-LogR1)/LogR1 + (LogR1 - PolyLog1pz)/PolyLog1pz + ((log-LogR1)/LogR1)* ((LogR1 - PolyLog1pz)/PolyLog1pz);
(LogR1 - PolyLog1pz)/PolyLog1pz -> (LogR1- LogR0)/LogR0 + (LogR0 - PolyLog1pz)/PolyLog1pz + ((LogR1- LogR0)/LogR0) * ((LogR0 - PolyLog1pz)/PolyLog1pz);
(LogR0 - PolyLog1pz)/PolyLog1pz -> (LogR0 -LogR)/LogR  + (LogR - PolyLog1pz)/PolyLog1pz + ((LogR0 -LogR)/LogR)*((LogR - PolyLog1pz)/PolyLog1pz);

# First we need to get an error of p03 (I think. There may well be a shorter path to a proof)

# layers of approx
(p03 - P03)/P03 -> (p03 - AP03)/AP03 + (AP03-P03)/P03 + ((p03 - AP03)/AP03) * ((AP03-P03)/P03);
(p03 - AP03)/AP03 -> (p03 - AP03R1)/AP03R1 + (AP03R1 - AP03)/AP03 +    ((p03 - AP03R1)/AP03R1) * ((AP03R1 - AP03)/AP03) ;
(AP03R1 - AP03)/AP03 -> (AP03R1 - AP03R0)/AP03R0 + (AP03R0 - AP03)/AP03 + ((AP03R1 - AP03R0)/AP03R0)*((AP03R0 - AP03)/AP03) ;

(AP03-P03)/P03 -> z*(p23-P23)/(1+z*P23);

# Now all the trick is to factor z, so as to divide by (1+epsilon) 
#(AP03R1 - AP03R0)/AP03R0 ->  ( (z*p23) * ((<float80ne>(z2*p23) - (z2*p23))/ (z2*p23)) ) / (1 + (z2/z)*p23)    ;
(AP03R1 - AP03R0)/AP03R0  -> ((<float80ne>(z2*p23) -  (z2*p23))/z)  / (1 + (z2/z)*p23) ;
(<float80ne>(z2*p23) -  (z2*p23))/z -> ((<float80ne>(z2*p23) -  (z2*p23))/(z2*p23)) *  (z2/z) * p23;
z2/z -> z*((z2-Z2)/Z2) + z;

(AP03R0 - AP03)/AP03 -> z*(((z2-Z2)/Z2)*p23) / (1 + z*p23);

#                         -----------rounding error--------------           ---- small ---
(LogR1 - LogR0)/LogR0 -> ((<float80ne>(z4*p47) - z4*p47)/(z4*p47)) * p47 * (z4/(p03+z4*p47)); 
# Now please Gappa remark that (z4/(p03+z4*p47)) is small 
z4/(p03+z4*p47) -> (z4/Z4) * (Z4 / (p03+z4*p47));
z4/Z4 -> (z4-Z4)/Z4 + 1;
Z4 / (p03+z4*p47) -> Z3/(p03/z + (z4/z) * p47);
z4/z -> Z3* (z4/Z4);
p03/z -> (p03/P03) * (P03/z);
p03/P03 -> (p03 - P03)/P03 + 1;
P03/z -> 1 + z*P23;

(LogR0 - LogR)/LogR -> ((z4-Z4)/z)*p47 / (p03/z + Z3*p47); 
(z4-Z4)/z -> ((z4-Z4) / Z4) * Z3;


(LogR - PolyLog1pz)/PolyLog1pz -> ((p03-P03)/z + Z3*(p47-P47)) / (P03/z + Z3*P47);
(p03-P03)/z -> ((p03-P03)/P03) * (P03/z); 

